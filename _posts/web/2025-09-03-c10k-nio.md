---
layout: posts
title:  "C10K ë¬¸ì œ í•´ê²°ì„ ìœ„í•œ Non-Blocking I/O ê¸°ë°˜ ì²˜ë¦¬ êµ¬ì¡°"
author_profile: true
sidbar:
  nav: "main"
category: "web"
description: "ì´ì „ë¶€í„° í†°ìº£ì€ Java NIO ê¸°ë°˜ì˜ Non-Blocking I/O ê¸°ë°˜ìœ¼ë¡œ ë™ì‘í•œë‹¤ëŠ” ë§ì„ ë“£ê¸°ëŠ” í•˜ì˜€ì§€ë§Œ ì´ì— ëŒ€í•´ ì œëŒ€ë¡œ ì´í•´ë¥¼ í•˜ì§€ ëª»í•˜ê³  ë‹¨ì§€ ì“°ë ˆë“œí’€ë§Œ ì‚¬ìš©í•œë‹¤ëŠ” ê²ƒ ì •ë„ë§Œ ì•Œê³  ìˆì—ˆë‹¤. ìµœê·¼ ìŠ¤í”„ë§ë¶€íŠ¸ì˜ ì›¹ ì„œë²„ ì„¤ì • ë“±ì˜ ê³¼ì •ì„ ê³µë¶€í•˜ë©° ë‹¤ì‹œ í†°ìº£ì˜ ê¸°ë³¸ì ì¸ ë™ì‘ ì›ë¦¬ì— ëŒ€í•´ ê³µë¶€í•´ë³´ê¸°ë¡œ í•˜ì˜€ë‹¤. ì´ ê³¼ì •ì—ì„œ í†°ìº£ê³¼ ê°™ì€ ì›¹ ì„œë²„ë“¤ì€ Non-Blocking I/O ë°©ì‹ì„ ì™œ ì‚¬ìš©í•˜ëŠ”ì§€, ë¬´ì—‡ì¸ì§€ì— ëŒ€í•´ ê³µë¶€í•´ë³¸ ë‚´ìš©ì„ ì •ë¦¬í•˜ê³ ì í•œë‹¤."
published: true
show_date: true
---

# ì„œë¡ 

&nbsp; ìŠ¤í”„ë§ë¶€íŠ¸ì˜ ë™ì‘ ì›ë¦¬ ë“±ì— ëŒ€í•´ ê³µë¶€ë¥¼ í•˜ë©´ í†°ìº£ì— ê´€í•œ ì´ì•¼ê¸°ëŠ” ë¹¼ë†“ì„ ìˆ˜ê°€ ì—†ëŠ” ì£¼ì œì´ë‹¤. í•„ìë„ ì´ì „ì— WAS(Web Application Server)ì¸ í†°ìº£ì´ ì–´ë– í•œ ë°©ë²•ê³¼ ì›ë¦¬ë¡œ ë™ì‘í•˜ëŠ”ì§€ ê¶ê¸ˆí•´ì„œ ì°¾ì•„ë³¸ ì ì´ ìˆë‹¤. Java NIOì™€ Non-Blocking I/O ë°©ì‹ì„ ê¸°ë°˜ìœ¼ë¡œ ë™ì‘í•˜ë©°, ì“°ë ˆë“œí’€ì„ í†µí•´ ìì›ì„ íš¨ìœ¨ì ìœ¼ë¡œ ì‚¬ìš©í•œë‹¤ëŠ” ì´ì•¼ê¸°ë¥¼ ë“£ê¸°ëŠ” í•˜ì˜€ì§€ë§Œ ì´ì— ê´€í•´ ë” ê¹Šì´ ì°¾ì•„ë³´ì§€ëŠ” ì•Šì•˜ì—ˆë‹¤. ìµœê·¼ ìŠ¤í”„ë§ê³¼ ìŠ¤í”„ë§ë¶€íŠ¸ì˜ ê¸°ë³¸ ë™ì‘ ì›ë¦¬ ë“±ì„ ë˜ëŒì•„ë³´ë©° ìŠ¤í”„ë§ë¶€íŠ¸ í”„ë¡œì íŠ¸ ì‹œì‘ ì‹œ ì›¹ ì„œë²„ê°€ ë§Œë“¤ì–´ì§€ëŠ” ê³¼ì •ì„ ì°¾ì•„ë³´ë©° ìì—°ìŠ¤ëŸ½ê²Œ í†°ìº£ì— ëŒ€í•´ì„œë„ ë‹¤ì‹œ ì°¾ì•„ë³¼ ìˆ˜ ìˆëŠ” ê¸°íšŒê°€ ìƒê²¼ë‹¤. 

&nbsp; ì˜ˆì „ì— ì°¾ì•„ë³´ì•˜ì„ ë•Œ ëª¨í˜¸í–ˆë˜ ê°œë…ì´ì—ˆë˜ NIO, Non-Blocking I/O ë“±ì— ëŒ€í•´ ìì„¸íˆ ì•Œì•„ë³´ê³ , ì´ê²ƒì´ ì™œ ì ìš©ì´ ë˜ëŠ” ê²ƒì¸ì§€ì— ëŒ€í•´ ê³„ì† ê¼¬ë¦¬ ì§ˆë¬¸ì„ ì´ì–´ë‚˜ê°”ë‹¤. ë”°ë¡œ íƒœë¸”ë¦¿ì— ì½”ë“œì™€ ë™ì‘ì„ ì •ë¦¬í•˜ì˜€ê³ , ì´ë²ˆ í¬ìŠ¤íŒ…ì—ì„œëŠ” ê°€ì¥ ê·¼ë³¸ì ì¸ ë™ì‘ ì›ë¦¬ì™€ ì™œ ì´ëŸ¬í•œ ë°©ì‹ìœ¼ë¡œ ë™ì‘í•˜ëŠ”ì§€ì— ê´€í•œ ë‚´ìš©ì„ ì„œìˆ í•˜ê³ ì í•œë‹¤.

# C10K Problem

<i class="fas fa-link" style="font-size: 13.5px; font-weight: bold;"></i> [The C10K Problem](https://www.kegel.com/c10k.html)

&nbsp; **C10K(Concurrent 10K) ë¬¸ì œ**ëŠ” 'í•˜ë‚˜ì˜ ì„œë²„ê°€ ë™ì‹œì— 1ë§Œëª…ì˜ í´ë¼ì´ì–¸íŠ¸ ìš”ì²­ì„ ì²˜ë¦¬í•˜ì—¬ì•¼í•  ë•Œ ë°œìƒí•˜ëŠ” ë¬¸ì œ'ì— ê´€í•œ ë‚´ìš©ì´ë‹¤.

&nbsp; 1999ë…„, ê°œë°œì Dan Kegelì´ í•´ë‹¹ ë¬¸ì œë¥¼ ì²˜ìŒ ì œê¸°í•˜ì˜€ìœ¼ë©°, ë‹¹ì‹œ ì„œë²„ í™˜ê²½ì—ì„œ ê·¹ë³µí•˜ì—¬ì•¼ í–ˆë˜ I/O ë° ì“°ë ˆë“œ ê´€ë ¨ ë¬¸ì œë“¤ê³¼ ì´ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•œ ë°©ë²•ë“¤ì„ ì œì‹œí•˜ì˜€ë‹¤. í˜„ì¬ëŠ” ì²˜ë¦¬ ê¸°ìˆ  ì™¸ì—ë„ í•˜ë“œì›¨ì–´ ìì²´ì˜ ì„±ëŠ¥ì´ ë§¤ìš° ì¢‹ì•„ì§€ë©° 1ë§Œëª… í´ë¼ì´ì–¸íŠ¸ ì •ë„ëŠ” ë¬´ë¦¬ê°€ ì—†ë‹¤. ê·¸ëŸ¬ë‚˜, 1999ë…„ ë‹¹ì‹œì—ëŠ” ì¸í„°ë„· ë¶ì´ ì¼ì–´ë‚˜ë©° íŠ¸ë˜í”½ì´ ê¸‰ê²©í•˜ê²Œ ì¦ê°€í•˜ë˜ ì‹œê¸°ë¡œ ì„œë²„ì˜ ì„±ëŠ¥ì´ ì´ë¥¼ ê·¹ë³µí•˜ì§€ ëª»í•˜ëŠ” ë¬¸ì œê°€ ë°œìƒí•˜ì˜€ë‹¤.

&nbsp; ì˜ˆë¥¼ ë“¤ì–´ í´ë¼ì´ì–¸íŠ¸ì˜ ìš”ì²­ë§ˆë‹¤ ì“°ë ˆë“œê°€ ë°°ì¹˜ë˜ì–´ 1:1 êµ¬ì¡°ë¡œ ì²˜ë¦¬í•˜ê²Œ ëœë‹¤ë©´, 1ë§Œëª…ì˜ í´ë¼ì´ì–¸íŠ¸ ë™ì‹œ ìš”ì²­ì„ ì²˜ë¦¬í•˜ê¸° ìœ„í•´ 1ë§Œê°œì˜ ì“°ë ˆë“œê°€ í•„ìš”í•˜ê²Œ ëœë‹¤. ë˜í•œ, Java 64bit VMì˜ ê²½ìš°ì—ëŠ” 1ê°œì˜ ì“°ë ˆë“œ ë‹¹ 1MB(1024k byte)ì˜ ë©”ëª¨ë¦¬ë¥¼ ì‚¬ìš©í•œë‹¤ê³  í•œë‹¤. ë”°ë¼ì„œ ë‹¨ìˆœ ì“°ë ˆë“œê°€ í• ë‹¹ë°›ì•„ì•¼í•˜ëŠ” ë©”ëª¨ë¦¬ì˜ í¬ê¸°ë§Œ ê³„ì‚°í•˜ë”ë¼ë„ 10GBê°€ ë„˜ëŠ”ë‹¤. ìµœê·¼ì—ëŠ” í•˜ë“œì›¨ì–´ ì„±ëŠ¥ì´ ì¢‹ì•„ì§€ë©° 64GB í˜¹ì€ ê·¸ ì´ìƒì˜ ë©”ëª¨ë¦¬ë„ ì¶œì‹œë˜ê¸° ë•Œë¬¸ì— ì´ëŠ” ê´œì°®ë‹¤ê³  ëŠë‚„ ìˆ˜ ìˆì§€ë§Œ, ì“°ë ˆë“œ ìì²´ê°€ 1ë§Œê°œê°€ ìˆë‹¤ëŠ” ê²ƒì´ ë¬¸ì œë‹¤. ìš°ì„ , ì†Œí”„íŠ¸ì›¨ì–´ì ìœ¼ë¡œ 1ë§Œê°œì˜ ì“°ë ˆë“œë¥¼ í—ˆìš©í•˜ì§€ ì•Šì„ ìˆ˜ë„ ìˆìœ¼ë©°, ê° ì“°ë ˆë“œê°€ CPU ì—°ì‚°ì„ ìˆ˜í–‰í•˜ê¸° ìœ„í•´ì„œëŠ” Context Switchingì´ ë°œìƒí•˜ê²Œ ëœë‹¤. Context Switching ìì²´ì˜ ì˜¤ë²„í—¤ë“œì™€ ìš”ì²­ì„ ì²˜ë¦¬í•˜ëŠ” ì—¬ëŸ¬ ì“°ë ˆë“œê°€ ìì‹ ì´ Execution Timeì„ ì–»ê¸° ìœ„í•´ ë‹¤ë¥¸ ì“°ë ˆë“œì™€ ê²½ìŸ ìƒíƒœ(Race Condition)ì— ë¹ ì§€ê²Œ ë˜ë©° ë°œìƒí•˜ëŠ” ì˜¤ë²„í—¤ë“œ ë“± ì—¬ëŸ¬ ê°€ì§€ ì„±ëŠ¥ ì €í•˜ê°€ ë°œìƒí•˜ê²Œ ëœë‹¤.

![rps](/assets/img/docs/web/c10k-nio/rps.png)

&nbsp; ìœ„ ê·¸ë¦¼ì€ **Apache httpd**ì™€ **nginx** ì›¹ ì„œë²„ì—ì„œ ë™ì‹œ ì‚¬ìš©ì ìˆ˜ì— ë”°ë¥¸ ì²˜ë¦¬ ê°€ëŠ¥í•œ RPS(Request Per Second)ë¥¼ ë‚˜íƒ€ë‚¸ ê·¸ë¦¼ì´ë‹¤. ë™ì‹œ ì‚¬ìš©ì ìˆ˜ê°€ ê¸‰ê²©íˆ ì¦ê°€í•  ìˆ˜ë¡ httpdëŠ” ì„±ëŠ¥ì´ ê¸‰ê²©í•˜ê²Œ ì €í•˜í•˜ì§€ë§Œ, nginxëŠ” ì„±ëŠ¥ì— í° ë³€í™”ê°€ ì—†ë‹¤. ë™ì‹œ ì‚¬ìš©ì ìˆ˜ ì¦ê°€ì— ë”°ë¥¸ RPS ì €í•˜ëŠ” ê³§ ì„œë¹„ìŠ¤ì˜ ì„±ëŠ¥ê³¼ ì‚¬ìš©ì ê²½í—˜ì˜ ì €í•˜ë¡œ ì´ì–´ì§€ê²Œ ë  ê²ƒì´ë‹¤. 

&nbsp; ì´ ë•Œ, nginxê°€ ì•ˆì •ì ì¸ íŠ¸ë˜í”½ì„ ë³´ì¥í•˜ê¸° ìœ„í•´ ë„ì…í•œ ë°©ë²•ì´ ê³§ C10K ë¬¸ì œì˜ í•´ê²°ì±…ê³¼ ë™ì¼í•˜ë‹¤.

# I/O

&nbsp; C10K ë¬¸ì œì™€ í•´ê²° ë°©ë²•ì— ëŒ€í•´ ìì„¸íˆ ì•Œì•„ë³´ê¸° ì „ì— I/Oì— ëŒ€í•´ ì •ë¦¬í•´ë³´ê³ ì í•œë‹¤. I/Oë¼ê³  í•˜ë©´ ë˜ê²Œ ì¶”ìƒì ì¸ ê°œë…ì´ì, í”íˆ í‚¤ë³´ë“œ ì…ë ¥ê³¼ ëª¨ë‹ˆí„° ì¶œë ¥ê³¼ ê°™ì€ ë‹¨ìˆœí•œ ì˜ˆì‹œê°€ ë¨¼ì € ìƒê°ë‚˜ê¸° ë•Œë¬¸ì— Non-Blocking I/Oë‚˜ ë„¤íŠ¸ì›Œí¬ I/O ë“±ì— ê´€í•´ ì•Œì•„ë³´ê¸° ì „ì— I/Oì— ëŒ€í•œ ê°œë…ì„ ë¨¼ì € í™•ë¦½í•˜ê³ ì í•œë‹¤.

&nbsp; I/OëŠ” ì£¼ë¡œ File Systemì´ ê´€ì—¬í•˜ëŠ” ì‘ì—…ìœ¼ë¡œ, í¬ê²Œ ì¢…ë¥˜ëŠ” ì•„ë˜ì™€ ê°™ë‹¤.

- **Network(Socket)**: ì„œë¡œ ë‹¤ë¥¸ ë…¸ë“œì— ì¡´ì¬í•˜ëŠ” í”„ë¡œì„¸ìŠ¤ ê°„ í†µì‹ (ì• í”Œë¦¬ì¼€ì´ì…˜ ë ˆë²¨)ìœ¼ë¡œ ì§„í–‰ë˜ëŠ” I/O ì‘ì—… 
- **File**: í•˜ë“œ ë””ìŠ¤í¬ì— ì¡´ì¬í•˜ëŠ” íŒŒì¼ì„ ë©”ëª¨ë¦¬ë¡œ ë¡œë“œí•´ íŒŒì¼ì„ ê¸°ì¤€ìœ¼ë¡œ ì§„í–‰ë˜ëŠ” I/O ì‘ì—…
- **Pipe**: í”„ë¡œì„¸ìŠ¤ ê°„ í†µì‹ ìœ¼ë¡œ ì§„í–‰ë˜ëŠ” I/O ì‘ì—…
- **Device**: ëª¨ë‹ˆí„°, í‚¤ë³´ë“œ ë“±ì˜ ì™¸ë¶€ ì¥ì¹˜ë¡œë¶€í„° ì§„í–‰ë˜ëŠ” I/O ì‘ì—…

&nbsp; ì¼ë°˜ì ìœ¼ë¡œ I/O ì‘ì—…ì€ ì‚¬ìš©ì ì •ì˜ í”„ë¡œì„¸ìŠ¤(User mode)ê°€ ë‹¨ë…ì ìœ¼ë¡œ ì²˜ë¦¬í•  ìˆ˜ ì—†ìœ¼ë©°, read/writeì™€ ê°™ì€ OS **System Call**ì˜ ë„ì›€ì´ í•„ìš”í•˜ë‹¤. 

&nbsp; ì‹œìŠ¤í…œ ì½œì˜ ë„ì›€ì„ ë°›ì•„ì•¼í•˜ê¸° ë•Œë¬¸ì— I/O ì‘ì—…ì„ ìš”ì²­í•œ TaskëŠ” ëŒ€ê¸°(block) ìƒíƒœì— ë“¤ì–´ê°€ê²Œ ë˜ë©°, CPUëŠ” ìœ ì € ëª¨ë“œì—ì„œ ì»¤ë„ ëª¨ë“œë¡œ ì „í™˜ì´ ë˜ì–´ I/O ì‘ì—…ì„ ìˆ˜í–‰í•˜ê²Œ ëœë‹¤. ì»¤ë„ í”„ë¡œì„¸ìŠ¤ê°€ I/O ì‘ì—…ì„ ì™„ë£Œí•˜ê²Œ ë˜ë©´ ë‹¤ì‹œ CPUì˜ ìƒíƒœëŠ” ì»¤ë„ ëª¨ë“œì—ì„œ ìœ ì € ëª¨ë“œë¡œ ì „í™˜ëœë‹¤. ì´í›„, I/O ê²°ê³¼ ë°ì´í„°ëŠ” ê¸°ì¡´ ìš”ì²­ Taskë¡œ ë°˜í™˜ë˜ê²Œ ë˜ë©° ëŒ€ê¸°(block)í•˜ê³  ìˆë˜ ì“°ë ˆë“œëŠ” ê¹¨ì–´ë‚˜ê²Œ ëœë‹¤.

> **Task**: Process or Thread

&nbsp; ì´ ë•Œ, ì‹œìŠ¤í…œ ì½œì„ ìš”ì²­í•œ ë’¤ I/O ì‘ì—…ì˜ ì™„ë£Œë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ë°©ì‹ì— ë”°ë¼ **Blocking I/O**ì™€ **Non-Blocking I/O**ê°€ ë‚˜ë‰˜ê²Œ ëœë‹¤. 

&nbsp; Blocking I/OëŠ” ì‘ì—…ì„ ìš”ì²­í•œ Taskê°€ I/O ì‘ì—…ì´ ì™„ë£Œë  ë•Œê¹Œì§€ ëŒ€ê¸°(block)í•œë‹¤. ì´ì™€ ë°˜ëŒ€ë¡œ ì‘ì—… ì™„ë£Œë¥¼ ê¸°ë‹¤ë¦¬ì§€ ì•Šê³  ì¦‰ì‹œ ìƒíƒœë¥¼ ë°˜í™˜í•˜ì—¬ ì‘ì—… ìš”ì²­ ì“°ë ˆë“œê°€ ë‹¤ìŒ ì‘ì—…ì„ í•  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” ê²ƒì´ Non-Blocking I/Oì´ë‹¤.

&nbsp; í˜„ì¬ ë‹¨ìˆœíˆ I/O ì‘ì—…ì„ í˜¸ì¶œí•œ ì“°ë ˆë“œì˜ ì‘ì—… ì™„ë£Œ ëŒ€ê¸° ì—¬ë¶€ì— ë”°ë¼ Blocking I/Oì™€ Non-Blocking I/Oë¥¼ êµ¬ë¶„í•˜ì˜€ë‹¤. ì´ëŠ” ë‘ ë°©ì‹ì„ ë¹„êµí•˜ê¸° ìœ„í•œ ê°œë…ì ì¸ ì„¤ëª…ì¼ ë¿ì´ë©°, Nginx, Tomcat ë“±ì—ì„œ ì‚¬ìš©ë˜ëŠ” ë¹„ë™ê¸° Non-Blocking I/O ë°©ì‹ì„ ì´í•´í•˜ê¸° ìœ„í•´ì„œëŠ” ë„¤íŠ¸ì›Œí¬ I/O (Socket I/O)ì—ì„œ Blocking ê°œë…ì— ëŒ€í•´ ìì„¸íˆ ì•Œì•„ë´ì•¼í•œë‹¤.

## Socket I/Oì—ì„œì˜ Blocking

![3-way-hs](/assets/img/docs/web/c10k-nio/three-way-hs.png)

![request](/assets/img/docs/web/c10k-nio/request.png)

&nbsp; Socket I/Oì—ì„œ ê° ì†Œì¼“ì€ TCP ì—°ê²°ì„ ìœ„í•˜ì—¬ ìš°ì„ ì€ **3-way handshake**ë¥¼ ì§„í–‰í•˜ê²Œ ëœë‹¤. 3-way handshake ê³¼ì •ì„ í†µí•˜ì—¬ ë‘ ë…¸ë“œê°„ ì†Œì¼“ìœ¼ë¡œ ì—°ê²°(connection)ì´ ë˜ê²Œ ëœë‹¤.

&nbsp; ì´í›„, ì‹¤ì œ ìš”ì²­ ë°ì´í„°ë¥¼ ë³´ë‚´ê²Œ ëœë‹¤. ì´ ë•Œ, í´ë¼ì´ì–¸íŠ¸ëŠ” <span class="code">write()</span> ì‹œìŠ¤í…œ ì½œì„ í˜¸ì¶œí•˜ì—¬ ì†¡ì‹  ë²„í¼ì— ë°ì´í„°ë¥¼ ì‚½ì…í•˜ê²Œ ë  ê²ƒì´ë‹¤. ì„œë²„ì—ì„œëŠ” í•´ë‹¹ ì†Œì¼“ì˜ File Descriptior(FD)ë¥¼ í†µí•´ <span class="code">read()</span> ì‹œìŠ¤í…œ ì½œì„ í˜¸ì¶œí•˜ì—¬ ìˆ˜ì‹  ë²„í¼ì— ë“¤ì–´ì˜¨ ë°ì´í„°ë¥¼ ì½ê²Œ ëœë‹¤. 

&nbsp; ì´ ë•Œ, <u>Socket I/Oì—ì„œ Blocking  ë°©ì‹ì´ë€ í´ë¼ì´ì–¸íŠ¸ ì¸¡ì—ì„œë„ <span class="code">write()</span> ì‹œìŠ¤í…œì½œì„ í˜¸ì¶œí•˜ëŠ” ë™ì•ˆ í•´ë‹¹ ì“°ê¸° ì‘ì—…ì„ í˜¸ì¶œí•œ ì“°ë ˆë“œê°€ ë©ˆì¶”ê²Œ ë˜ê³ , ì„œë²„ ì¸¡ì—ì„œë„ <span class="code">read()</span> ì‹œìŠ¤í…œì½œì„ í˜¸ì¶œí•œ ì“°ë ˆë“œëŠ” ë°ì´í„°ê°€ ìˆ˜ì‹  ë²„í¼ì— ë„ì°©í•˜ì—¬ ì½ê¸° ì‘ì—…ì´ ì™„ë£Œë˜ê¸°ê¹Œì§€ ëŒ€ê¸°</u>í•˜ê²Œ ë˜ëŠ” ë°©ì‹ì„ ì˜ë¯¸í•œë‹¤.

&nbsp; ë§Œì•½, Socket I/Oì—ì„œ C10K + Blocking ìƒí™©ì„ ê°€ì •í•œë‹¤ë©´ ë‹¤ìŒê³¼ ê°™ì„ ê²ƒì´ë‹¤.

- <div>1ë§Œëª…ì˜ í´ë¼ì´ì–¸íŠ¸ì™€ TCP ì»¤ë„¥ì…˜ì´ ë§ºì–´ì§€ë©°, 1ë§Œê°œì˜ ì“°ë ˆë“œê°€ ì„œë²„ì— ìƒì„± <br /><span style="font-family: 'Noto Sans KR'; font-weight: bold;">â‡’ Context Switching ì˜¤ë²„í—¤ë“œ</span></div>
- <div>1ë§Œëª…ì˜ í´ë¼ì´ì–¸íŠ¸ì˜ ìš”ì²­ìœ¼ë¡œ ì¸í•œ ìˆ˜ì‹  ë²„í¼ ë‚´ ë¶€í•˜(ì›Œí¬ë¡œë“œ) ê¸‰ì¦<br/><span style="font-family: 'Noto Sans KR'; font-weight: bold;">â‡’ ì—°ì‡„ì ì¸ ë³‘ëª©í˜„ìƒ ë°œìƒ</span></div>
- <div>Blocking I/Oì´ê¸° ë•Œë¬¸ì— TCP ì»¤ë„¥ì…˜ ì‹œì ë¶€í„° ë°ì´í„°ë¥¼ ìˆ˜ì‹ í•˜ê³ , ì´ë¥¼ ì²˜ë¦¬í•˜ì—¬ ì‘ë‹µí•˜ê¸°ê¹Œì§€ ì“°ë ˆë“œê°€ ì ìœ <br/><span style="font-family: 'Noto Sans KR'; font-weight: bold;">â‡’ ë‹¤ìˆ˜ ì“°ë ˆë“œì—ì„œ IDLEí•œ ì‹œê°„ ë°œìƒ</span></div> 

&nbsp; ìœ„ì™€ ê°™ì€ ë¬¸ì œë“¤ì´ ì˜ˆìƒë˜ë©°, ì´ëŠ” ë‹¹ì—°íˆ C10K ë¬¸ì œì—ì„œ ë¹„ë™ê¸°, Non-Blocking I/O êµ¬ì¡°ê°€ í•´ê²°ì±…ì¸ ì´ìœ ì¸ ê²ƒì´ë‹¤. ê²°êµ­ ì•ì„  2ê°€ì§€ ë¬¸ì œë„, ì»¤ë„¥ì…˜ë¶€í„° ìš”ì²­ì˜ ì²˜ë¦¬ê¹Œì§€ ìš”ì²­ ë‹¹ í•˜ë‚˜ì˜ ì“°ë ˆë“œê°€ ì™„ì „íˆ ì ìœ í•˜ê²Œ ë˜ì–´ ë°œìƒí•˜ëŠ” <u>ì“°ë ˆë“œì˜ IDLEí•œ ì‹œê°„ ë‚­ë¹„ ë¬¸ì œ</u>ë¡œ ì´ì–´ì§„ë‹¤.

&nbsp; ê·¸ëŸ¬ë‚˜, ì²˜ìŒì— í•„ìëŠ” <span style="font-style: italic">"3-handshake ì´í›„ ì‹¤ì œ ìš”ì²­ì´ ë„ì°©í•˜ëŠ” ì‚¬ì´ ë°œìƒí•˜ëŠ” IDLEí•œ ì‹œê°„ì´ ê³¼ì—° ì˜í–¥ì´ í´ê¹Œ?"</span>ë¼ëŠ” ìƒê°ì„ í•˜ì˜€ë‹¤.

![pr-timing](/assets/img/docs/web/c10k-nio/pr-timing.png)

&nbsp; ìœ„ ê·¸ë¦¼ì€ Github Pull Requestì— ì ‘ì† ì‹œ API ì‘ë‹µ íƒ€ì´ë° ë‚´ì—­ì„ í™•ì¸í•œ ê²°ê³¼ì´ë‹¤. ë¬¼ë¡ , PR Descriptionì˜ ì¼ë¶€ ì»´í¬ë„ŒíŠ¸ì— ëŒ€í•œ ìš”ì²­ì´ì§€ë§Œ ë‹¨ìˆœ ê³„ì‚°ì„ ìœ„í•˜ì—¬ í•´ë‹¹ ìš”ì²­ì„ ì˜ˆì‹œë¡œ ì„ íƒí•œë‹¤.

&nbsp; ìš”ì²­/ì‘ë‹µ ì„¹ì…˜ì—ì„œ 'ì„œë²„ ì‘ë‹µì„ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘'ì˜ ì†Œìš”ëœ ì‹œê°„ì€ 675.74msì´ë‹¤. ì´ëŠ” 3-way handshakeë¡œ TCP Connectionì„ ë§ºì€ í›„ ì‹¤ì œ ìš”ì²­ í›„ ì‘ë‹µì´ ì˜¨ ì‹œê°„ì„ ê¸°ë¡í•œ ê²ƒì´ë‹¤. ë”°ë¼ì„œ, ë‹¨ìˆœ í¸ë„ ì‹œê°„ì„ ê³„ì‚°í•˜ë©´ 675.74 / 2 = 337.87ms ì´ë‹¤.

&nbsp; ê¹ƒí—ˆë¸ŒëŠ” CDN ë“±ì˜ ë°©ë²•ìœ¼ë¡œ ê°œì„ ëœ ì‘ë‹µ ì†ë„ë¥¼ ê°€ì§€ê³  ìˆì§€ë§Œ ìš°ë¦¬ê°€ ìš´ì˜í•˜ëŠ” ì„œë²„ëŠ” ì´ë³´ë‹¤ ë”ìš± ëŠë¦´ ê²ƒì´ë‹¤. ì´ ë•Œ, í´ë¼ì´ì–¸íŠ¸ì˜ ë™ì‹œ ìš”ì²­ì´ ê¸‰ê²©í•˜ê²Œ ëª°ë¦¬ëŠ” ìƒí™©ì´ ì˜¨ë‹¤ë©´ ì•½ 300msì˜ IDLEí•œ ì‹œê°„ì´ ë³‘ëª© í˜„ìƒê³¼ ê²¹ì³ ì„œë²„ì˜ ì„±ëŠ¥ì„ ë”ìš± ì•…í™”ì‹œí‚¬ ê²ƒì´ë‹¤.

## Non-Blocking I/O

&nbsp; ì•ì„œ ì•Œì•„ë³¸ Socket I/Oì—ì„œ Blocking ë°©ì‹ìœ¼ë¡œ ë™ì‘í•  ê²½ìš° ë°œìƒí•  ìˆ˜ ìˆëŠ” ë¬¸ì œì ì„ í•´ê²°í•˜ê¸° ìœ„í•˜ì—¬ ë“±ì¥í•œ ê²ƒì´ **Non-Blocking I/O**ì´ë‹¤.

&nbsp; Non-Blocking I/OëŠ” I/O ì‘ì—…ì„ ìš”ì²­í•œ ì“°ë ˆë“œë¥¼ ëŒ€ê¸°(block)ì‹œí‚¤ì§€ ì•Šê³  I/O ìš”ì²­ì— ëŒ€í•œ í˜„ì¬ ìƒíƒœë¥¼ ë°”ë¡œ ì‘ë‹µí•œë‹¤. ì˜ˆë¥¼ ë“¤ì–´ ì„œë²„ ì¸¡ ì†Œì¼“ì˜ ìˆ˜ì‹  ë²„í¼ì— ëŒ€í•œ <span class="code">read()</span> ì‹œìŠ¤í…œì½œì„ Non-Blocking ëª¨ë“œë¡œ í˜¸ì¶œí•˜ê²Œ ë˜ë©´ ì»¤ë„ ëª¨ë“œë¡œ Context Switchingì´ ë˜ê³ , ì»¤ë„ì€ I/O ì‘ì—…ì„ ìˆ˜í–‰í•  ê²ƒì´ë‹¤. ì—¬ê¸°ê¹Œì§€ëŠ” Blocking ë°©ì‹ê³¼ ë™ì¼í•˜ë‚˜, I/O ì‘ì—…ì´ ì‹œì‘í•¨ê³¼ ë™ì‹œì— ì¦‰ì‹œ ê²°ê³¼ê°’ì„ ë°˜í™˜í•˜ë©° ë‹¤ì‹œ CPUëŠ” ìœ ì € ëª¨ë“œë¡œ ìŠ¤ìœ„ì¹­í•˜ê²Œ ëœë‹¤. ë¦¬ëˆ…ìŠ¤ì˜ ê²½ìš°ì—ëŠ” ë°ì´í„° ì²˜ë¦¬ ì‘ì—…ì´ ì™„ë£Œë˜ì§€ ì•Šì•˜ì„ ê²½ìš° -1ì„ ë¦¬í„´í•œë‹¤.

&nbsp; ì´ë ‡ê²Œ ëœë‹¤ë©´, ì›ë˜ I/O ìš”ì²­í•œ ì“°ë ˆë“œëŠ” ì´ì–´ì„œ ë‹¤ë¥¸ ì‘ì—…ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆê²Œ ë˜ë©°, ì´í›„ ì»¤ë„ì—ì„œëŠ” ì†Œì¼“ì˜ ìˆ˜ì‹  ë²„í¼ì— ìš”ì²­ì˜¨ ë°ì´í„°ë¥¼ ìœ„ì¹˜ì‹œí‚¨ ë’¤ I/O ì‘ì—…ì´ ì™„ë£Œë˜ì—ˆìŒì„ ì•Œë¦¬ê²Œ ëœë‹¤.

&nbsp; ì—¬ê¸°ì„œ <u>"I/O ì‘ì—… ìš”ì²­ì„ ë³´ë‚¸ ì“°ë ˆë“œëŠ” ì´ë¯¸ ë‹¤ë¥¸ ì‘ì—…ì„ ìˆ˜í–‰í•˜ê³  ìˆì„í…ë° ì–´ë–»ê²Œ I/O ì‘ì—…ì´ ì™„ë£Œë˜ì—ˆìŒì„ ì•Œë¦´ ìˆ˜ ìˆëŠ”ê±°ì§€?"</u>ë¼ëŠ” ì˜ë¬¸ì´ ìƒê¸´ë‹¤.

&nbsp; I/O ì‘ì—…ì˜ ì™„ë£Œë¥¼ í™•ì¸í•˜ëŠ” ë°©ë²•ì€ ì—¬ëŸ¬ê°€ì§€ê°€ ìˆì§€ë§Œ í¬ê²Œ **Polling ë°©ì‹**ê³¼ **ì´ë²¤íŠ¸ ê¸°ë°˜ ì²˜ë¦¬ ë°©ì‹**ì´ ìˆë‹¤. 

&nbsp; **Polling ë°©ì‹**ì€ ì£¼ê¸°ì ìœ¼ë¡œ ì»¤ë„ì— <span class="code">read</span> ì‹œìŠ¤í…œ ì½œì„ ë³´ë‚´(polling) ë°ì´í„°ê°€ ì¤€ë¹„ë˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ëŠ” ë°©ì‹ì´ë‹¤. ê·¸ëŸ¬ë‚˜, ê°„ë‹¨í•œ ë¬´í•œë£¨í”„ë¡œ Polling ë°©ì‹ êµ¬í˜„ ì‹œ Busy Waiting ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆë‹¤.

&nbsp; ë”°ë¼ì„œ, íš¨ìœ¨ì ì¸ í´ë§ ë°©ì‹ êµ¬í˜„ì„ ìœ„í•´ **ì´ë²¤íŠ¸ ê¸°ë°˜ ì²˜ë¦¬ ë°©ì‹**ì´ ì‚¬ìš©ëœë‹¤. ì´ë²¤íŠ¸ ê¸°ë°˜ ì²˜ë¦¬ ë°©ì‹ì€ read/writeê°€ ì¤€ë¹„ëœ ê²½ìš°ì— ì´ë²¤íŠ¸ë¥¼ ë°œìƒì‹œí‚¤ê³ , ì´ë¥¼ ì“°ë ˆë“œì—ì„œ ê°ì§€í•´ ê·¸ ë‹¤ìŒ ì‘ì—…ì„ ì´ì–´ ë‚˜ê°ˆ ìˆ˜ ìˆë„ë¡ í•˜ëŠ” ë°©ë²•ì´ë‹¤.

&nbsp; ì´ë²¤íŠ¸ ê¸°ë°˜ ì²˜ë¦¬ ë°©ì‹ì—ëŠ” **I/O Multiplexing**ê³¼ **Callback/Signal**ê°€ ì¡´ì¬í•œë‹¤.

&nbsp; **Multiplexing(ë‹¤ì¤‘í™”)**ì€ ì—¬ëŸ¬ ì „ì†¡ ì‹ í˜¸ë“¤ì„ í•˜ë‚˜ì˜ íšŒì„  ë˜ëŠ” ë§¤ì²´ë¥¼ ì‚¬ìš©í•˜ì—¬ í•œ ë²ˆì— ì „ì†¡í•˜ì—¬ ì „ì†¡ ì†ë„ì™€ íš¨ìœ¨ì„ ë†’ì´ëŠ” ê¸°ìˆ ì„ ì˜ë¯¸í•œë‹¤. ì´ë¥¼ ê¸°ë°˜ìœ¼ë¡œ Socket I/Oì—ì„œ **I/O Multiplexing**ì„ ìƒê°í•´ë³´ë©´ I/O ì‘ì—…ì„ ì§„í–‰í•˜ëŠ” ì—¬ëŸ¬ ì†Œì¼“ì˜ ìƒíƒœë¥¼ í•˜ë‚˜ì˜ ì“°ë ˆë“œì—ì„œ ê°ì§€í•  ìˆ˜ ìˆê²Œë˜ëŠ” ê²ƒì„ ì˜ë¯¸í•œë‹¤. ì¦‰, ë©€í‹°í”Œë ‰ì‹± ë°©ì‹ìœ¼ë¡œ 2ê°œ ì´ìƒì˜ ì†Œì¼“ì— ëŒ€í•œ <span class="code">read</span> ì‹œìŠ¤í…œ ì½œì„ í˜¸ì¶œí•˜ê²Œ ë˜ëŠ” ê²ƒì´ë‹¤. ì´ ë•Œ, ë©€í‹°í”Œë ‰ì‹± ì‹œìŠ¤í…œ ì½œì„ ìš”ì²­í•œ ì“°ë ˆë“œëŠ” Block ë˜ëŠ” Non-Block ë°©ì‹ ëª¨ë‘ ë™ì‘ì´ ê°€ëŠ¥í•˜ë‹¤. ì´í›„, ì—¬ëŸ¬ ì†Œì¼“ì— ëŒ€í•œ ì´ë²¤íŠ¸(read/write)ê°€ ë°œìƒí•œ ê²½ìš°ì— OS ì»¤ë„ì—ì„œ ì—¬ëŸ¬ ì´ë²¤íŠ¸ë¥¼ ì‘ë‹µí•˜ê²Œ ëœë‹¤.

&nbsp; ë” ë‚˜ì•„ê°€ <u>I/Oë¥¼ ë‹´ë‹¹í•˜ëŠ” ì“°ë ˆë“œë¥¼ ë”°ë¡œ ë‘ê³ </u>, <u>ì“°ë ˆë“œí’€ì— ì—¬ëŸ¬ ê°œì˜ ì“°ë ˆë“œë¥¼ ë¯¸ë¦¬ ë§Œë“¤ì–´ë‘ê³  I/O ì‘ì—… ì™„ë£Œ ì´ë²¤íŠ¸ ë°œìƒ ì‹œì—ë§Œ ê° ìš”ì²­ë§ˆë‹¤ ì“°ë ˆë“œë¥¼ í• ë‹¹</u>í•˜ì—¬ ì²˜ë¦¬í•œë‹¤ë©´ ì“°ë ˆë“œì˜ ìˆ˜ë„ ì œí•œí•  ìˆ˜ ìˆì„ ë¿ë§Œ ì•„ë‹ˆë¼ ë¶ˆí•„ìš”í•œ IDLE ì‹œê°„ ë‚­ë¹„ë¥¼ ë§‰ì„ ìˆ˜ ìˆë‹¤. 

&nbsp; ì´ë ‡ë“¯ I/O Multiplexing ë°©ì‹ì€ Tomcat, Netty(WebFlux), NodeJS, Nginxì™€ ê°™ì€ ì„œë²„ì‚¬ì´ë“œ í”„ë¡œê·¸ë¨ì—ì„œ ì ìš©ë˜ì–´ìˆë‹¤.

&nbsp; ìµœê·¼ ì‚¬ìš©ë˜ëŠ” I/O Multiplexing ì‹œìŠ¤í…œì½œì˜ ì¢…ë¥˜ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.

- epoll: Linuxì—ì„œ ì‚¬ìš©
- kqueue: MacOS(BSD Unix ê¸°ë°˜)ì—ì„œ ì‚¬ìš©
- IOCP(I/O Completion Port): Windowsì—ì„œ ì‚¬ìš©

&nbsp; í•„ìëŠ” í•´ë‹¹ í¬ìŠ¤íŒ…ì„ ì‘ì„±í•˜ê¸° ì „ì— Tomcatì˜ ì½”ë“œë¥¼ ë””ë²„ê¹…í•´ë³´ë©´ ì €ìˆ˜ì¤€ì˜ ì½”ë“œë“¤ê³¼ í†°ìº£ì—ì„œ ì‚¬ìš©ë˜ëŠ” Acceptor, Poller, Selector ë“±ì˜ êµ¬í˜„ì²´ ì½”ë“œë“¤ì„ ì°¾ì•„ë³´ë˜ ì¤‘ `poll()` ë„¤ì´í‹°ë¸Œ ë©”ì„œë“œë¥¼ ë°œê²¬í•˜ì˜€ë‹¤.

<div style="display: flex; justify-content: center;">
    <img src="/assets/img/docs/web/c10k-nio/kqueue-poll.png" alt="kqueue-poll">
</div>

&nbsp; ë””ë²„ê¹…ì„ í•˜ë©° ê³ ìˆ˜ì¤€ â†’ ì €ìˆ˜ì¤€ì˜ ì½”ë“œë¥¼ ì°¾ì•„ë³´ë©° "ê·¸ë˜ì„œ I/O ì¤€ë¹„ê°€ ì™„ë£Œëœ Channel(Socket)ì€ ì–´ë–»ê²Œ ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ ì•„ëŠ”ê±´ë°?"ë¼ëŠ” ì˜ë¬¸ì„ ê°€ì§€ê²Œ ë˜ì—ˆê³ , ë„¤ì´í‹°ë¸Œ ë©”ì„œë“œë¡œ ì œê³µë˜ëŠ” `KQueueSelectorImpl.poll(...)`ì„ ë°œê²¬í•˜ì—¬ ì´ë¥¼ ì´í•´í•  ìˆ˜ ìˆì—ˆë‹¤. 

&nbsp; [epoll ì‹œìŠ¤í…œì½œ](https://man7.org/linux/man-pages/man7/epoll.7.html)ì— ëŒ€í•œ ì„¤ëª…ì„ í™•ì¸í•´ë³´ë©´ ì´ë²¤íŠ¸ ë°œìƒ(ready) ì‹œ ì´ë¥¼ ì•Œë ¤(return) ë™ì‘í•œë‹¤ëŠ” ë‚´ìš©ì„ ì•Œ ìˆ˜ ìˆë‹¤.

&nbsp; MacOSì—ì„œ ì‚¬ìš©í•˜ëŠ” kqueue ë°©ì‹ì„ ì‚¬ìš©í•˜ëŠ”ë° ì´ë²¤íŠ¸ë¥¼ ì•Œë¦¬ê¸° ìœ„í•œ ì‹œìŠ¤í…œ ì½œë¡œëŠ” kevent ì‹œìŠ¤í…œ ì½œì„ ì‚¬ìš©í•˜ê²Œ ëœë‹¤. [kevent ì‹œìŠ¤í…œ ì½œ](https://man.freebsd.org/cgi/man.cgi?query=kevent&manpath=FreeBSD+9.0-RELEASE)ì„ ì‚¬ìš©í•œë‹¤. ì´ ë˜í•œ, ì´ë²¤íŠ¸ íì—ì„œ ì´ë²¤íŠ¸ë¥¼ ê°ì§€í•  ìš”ì†Œë¥¼ ë“±ë¡í•˜ê³ , ì´í›„ ì´ë²¤íŠ¸ë¥¼ ì•Œë ¤ ë™ì‘í•œë‹¤ëŠ” ë‚´ìš©ì´ ëª…ì‹œë˜ì–´ ìˆë‹¤.

&nbsp; **Callback/Signal** ë°©ì‹ì€ ìœ ì € ì“°ë ˆë“œê°€ I/O ì‘ì—… ìš”ì²­ì„ Non-Blocking ë°©ì‹ìœ¼ë¡œ ì‹œìŠ¤í…œ ì½œì„ ë³´ë‚´ë©´ ì‘ë‹µì„ ë°›ì§€ ì•Šì€ ì±„ ë°”ë¡œ ë‹¤ë¥¸ ë¡œì§ì„ ìˆ˜í–‰í•˜ê²Œ ëœë‹¤. ì´í›„, OS ì»¤ë„ì—ì„œ I/O ì‘ì—… ì™„ë£Œ ì‘ë‹µì„ ë°›ê²Œ ë˜ë©´ ì½œë°±(Callback)ì´ë‚˜ ì‹œê·¸ë„(Signal) ìœ ì € ì“°ë ˆë“œë¡œ ë³´ë‚´ ì´ë¥¼ ì‹¤í–‰ì‹œí‚¤ëŠ” ë“±ìœ¼ë¡œ ì´í›„ ì‘ì—…ì„ ì²˜ë¦¬í•˜ê²Œ ëœë‹¤. ì´ëŠ” ìë°”ìŠ¤í¬ë¦½íŠ¸ ê¸°ë°˜ì¸ NodeJSì—ì„œ ì£¼ë¡œ ì‚¬ìš©ëœë‹¤ê³  í•œë‹¤.


## Synchronous / Asynchronous

&nbsp; ë¸”ë¡œí‚¹ê³¼ ë…¼ë¸”ë¡œí‚¹ì„ ì´ì•¼ê¸°í•˜ë©´ **ë™ê¸°ì™€ ë¹„ë™ê¸°**ì— ëŒ€í•œ ë‚´ìš©ì€ ë¹ ì§ì—†ì´ ë‚˜ì˜¤ê²Œ ëœë‹¤. ì•ì„œ ë¸”ë¡œí‚¹-ë…¼ë¸”ë¡œí‚¹ì˜ êµ¬ë¶„ì— ê´€í•œ ì„¤ëª…ì—ì„œëŠ” I/O ì‘ì—… ê°™ì€ íŠ¹ì • ìš”ì²­ì„ ë³´ë‚¸ ì“°ë ˆë“œê°€ í•´ë‹¹ ì‘ì—…ì˜ 'ì™„ë£Œ' ì‘ë‹µì´ ì˜¬ ë•Œê¹Œì§€ ëŒ€ê¸°í•˜ëŠ”ì§€ ì—¬ë¶€ì— ë”°ë¼ ë‚˜ë‰œë‹¤ê³  í•˜ì˜€ë‹¤.

&nbsp; ë™ê¸°ì™€ ë¹„ë™ê¸°ëŠ” I/O ìš”ì²­ ì™„ë£Œ ì‘ë‹µì˜ ê²°ê³¼ë¥¼ ì–´ë–¤ ì“°ë ˆë“œê°€ ì²˜ë¦¬í•˜ëƒì— ë”°ë¼ ë‚˜ë‰œë‹¤.

&nbsp; **ë™ê¸°(Synchronous)** ë°©ì‹ì€ I/O ì‘ì—…ì„ ìš”ì²­(í˜¸ì¶œ)í•œ ì“°ë ˆë“œê°€ ì§ì ‘ ì‘ë‹µ ì²˜ë¦¬ë¥¼ ìˆ˜í–‰í•˜ëŠ” ê²½ìš°ì´ë©°, ì‘ì—…ì˜ ìˆœì„œ ë³´ì¥ì´ ë˜ì–´ì•¼í•œë‹¤.

&nbsp; **ë¹„ë™ê¸°(Asynchronous)** ë°©ì‹ì€ ì»¤ë„ë¡œë¶€í„° <span class="code">notify</span>ë¥¼ ë°›ê±°ë‚˜ <span class="code">callback</span>ì„ í†µí•´ í†µí•´ ì•Œë¦¼ì„ ë°›ê²Œ ë˜ë©´, I/O ì‘ì—…ì„ ìš”ì²­í•œ ì“°ë ˆë“œê°€ ì§ì ‘ ê²°ê³¼ë¥¼ ì²˜ë¦¬í•˜ì§€ ì•Šê³ , ë‹¤ë¥¸ ì“°ë ˆë“œê°€ ì²˜ë¦¬ë¥¼ ë‹´ë‹¹í•˜ëŠ” ë°©ì‹ì„ ì˜ë¯¸í•œë‹¤.

&nbsp; ë”°ë¼ì„œ, <u>read/write ì‹œìŠ¤í…œì½œì„ ë¸”ë¡œí‚¹ ëª¨ë“œë¡œ í˜¸ì¶œí•˜ë“ , ë…¼ë¸”ë¡œí‚¹ ëª¨ë“œë¡œ í˜¸ì¶œí•˜ë“  ê²°êµ­ ìš”ì²­ì„ í•œ ì“°ë ˆë“œì—ì„œ ì§ì ‘ ì‘ë‹µì„ ë°›ì•„ ì²˜ë¦¬ë¥¼ í•´ì•¼í•˜ê¸° ë•Œë¬¸ì— ë™ê¸°(Synchronous)ì— í•´ë‹¹</u>í•˜ê²Œ ëœë‹¤. 

# Java NIO

&nbsp; Javaë¡œ ì½”ë”© í…ŒìŠ¤íŠ¸ë¥¼ í•´ë³¸ ê²½í—˜ì´ ìˆê±°ë‚˜, íŒŒì¼ ì½ê¸°/ì“°ê¸° ë“±ì˜ ì‘ì—…ì„ ì§„í–‰í•´ ë³¸ ê²½í—˜ì´ ìˆë‹¤ë©´ `java.io` íŒ¨í‚¤ì§€ëŠ” ìµìˆ™í•  ê²ƒì´ë‹¤.

&nbsp; ê·¸ëŸ¬ë‚˜, ì»´í“¨íŒ… ê¸°ìˆ ì´ ë°œì „í•¨ì— ë”°ë¼ **ë©€í‹°ì“°ë ˆë”©**ì´ ê¸°ë³¸ì ì¸ ìŠ¤í™ì´ ë˜ë©°, ê¸°ì¡´ì˜ I/O íŒ¨í‚¤ì§€ì—ì„œ ì—¬ëŸ¬ê°€ì§€ ë¬¸ì œì ì´ ë°œê²¬ë˜ì—ˆë‹¤. ì´ë¥¼ ê°œì„ í•˜ê¸° ìœ„í•´ì„œ ê¸°ì¡´ì˜ `java.io` íŒ¨í‚¤ì§€ë¥¼ ìˆ˜ì •í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼, ìƒˆë¡œìš´(new) I/O ê´€ë ¨ íŒ¨í‚¤ì§€ë¥¼ ë§Œë“¤ì–´ **Java NIO(New I/O)**ë¼ëŠ” ì´ë¦„ì´ ë¶™ê²Œëœ ê²ƒì´ë‹¤.

&nbsp; í”íˆ ì›ë˜ì˜ I/O ë°©ì‹ì€ `read()`ë¥¼ í˜¸ì¶œí•œ ê²½ìš° ë¸”ë¡œí‚¹ í˜•íƒœë¡œ ë™ì‘í•˜ê¸° ë•Œë¬¸ì— **BIO**ë¡œ ë¶ˆë¦¬ë©°, **NIO**ëŠ” ë…¼ë¸”ë¡œí‚¹ ë°©ì‹ì˜ ë™ì‘ì„ ì§€ì›í•˜ê¸° ë•Œë¬¸ì— Non-Blocking I/Oë¼ëŠ” ì˜ë¯¸ë¡œ í•´ì„ë˜ì§€ë§Œ, ì •í™•í•œ ì˜ë¯¸ë¡œëŠ” New I/Oë¥¼ ì˜ë¯¸í•œë‹¤. NIOì—ì„œë„ Blocking í˜•íƒœë¡œ ë™ì‘ì„ í•˜ë„ë¡ ì§€ì›í•˜ê¸° ë•Œë¬¸ì— NIO != Non-Blocking I/O ì¸ ê²ƒì´ë‹¤.

&nbsp; ê¸°ì¡´ì˜ BIO ë°©ì‹ì—ì„œëŠ” I/O ì‘ì—… ì‹œì— ìš”ì²­ ì“°ë ˆë“œê°€ ë¸”ë¡œí‚¹ë˜ëŠ” ë¬¸ì œì™€ ë”ë¶ˆì–´, <u>ìŠ¤íŠ¸ë¦¼(Stream) ê¸°ë°˜</u>ìœ¼ë¡œ ë™ì‘í•˜ê¸° ë•Œë¬¸ì— ì…ë ¥ ìŠ¤íŠ¸ë¦¼ì—ì„œ N Byteê°€ ì…ë ¥ë˜ë©´, ì¶œë ¥ ìŠ¤íŠ¸ë¦¼ì—ì„œë„ ë™ì¼í•˜ê²Œ N Byteë¥¼ ì½ê²Œë˜ì–´ ì„±ëŠ¥ ìƒì˜ ë¬¸ì œë„ ì¡´ì¬í•˜ì˜€ë‹¤. ì´ì™¸ì—ë„ ë©€í‹°ì“°ë ˆë”© í™˜ê²½ì—ì„œ ë…¼ë¸”ë¡œí‚¹ ì§€ì›ì„ ìœ„í•œ ëª‡ ê°€ì§€ ë°©ë²•ë“¤ì´ ì¶”ê°€ë˜ì–´ NIOê°€ ë“±ì¥í•˜ê²Œ ë˜ì—ˆë‹¤. 

&nbsp; Java NIOì—ì„œ ì œê³µí•˜ëŠ” í•µì‹¬ ì¶”ìƒí™” ê¸°ìˆ ì€ <u>Buffer, Encoder/Decoder, Channel, Selectorì™€ SelectionKeyë¥¼ í™œìš©í•œ Multiplexing</u>ì´ë‹¤.

&nbsp; ìš°ì„ , í†°ìº£ì—ì„œ ì‚¬ìš©í•˜ëŠ” `NioChannel`ì€ ë‹¤ìŒê³¼ ê°™ë‹¤. 

```java
/**
 * Base class for a SocketChannel wrapper used by the endpoint.
 * This way, logic for an SSL socket channel remains the same as for
 * a non SSL, making sure we don't need to code for any exception cases.
 */
public class NioChannel implements ByteChannel, ScatteringByteChannel, GatheringByteChannel {

    protected SocketChannel sc = null;

    /**
     * Reads a sequence of bytes from this channel into the given buffer.
     *
     * @param dst The buffer into which bytes are to be transferred
     * @return The number of bytes read, possibly zero, or <code>-1</code> if
     *         the channel has reached end-of-stream
     * @throws IOException If some other I/O error occurs
     */
    @Override
    public int read(ByteBuffer dst) throws IOException {
        return sc.read(dst);
    }

    /**
     * Writes a sequence of bytes to this channel from the given buffer.
     *
     * @param src The buffer from which bytes are to be retrieved
     * @return The number of bytes written, possibly zero
     * @throws IOException If some other I/O error occurs
     */
    @Override
    public int write(ByteBuffer src) throws IOException {
        checkInterruptStatus();
        if (!src.hasRemaining()) {
            // Nothing left to write
            return 0;
        }
        return sc.write(src);
    }
}
```

&nbsp; `NioChannel`ì€ í†°ìº£ì—ì„œ ì‚¬ìš©ë˜ë©° í´ë¼ì´ì–¸íŠ¸ì™€ ì—°ê²°ì„ ë‚˜íƒ€ë‚´ëŠ” ê°ì²´ì¸ `SocketChannel`ì„ ê°ì‹¸ëŠ” SocketChannel Wrapperì´ë‹¤.
í•´ë‹¹ í´ë˜ìŠ¤ ë‚´ë¶€ì—ì„œ `SocketChannel`ì˜ `read(ByteBuffer)`ì™€ `write(ByteBuffer)`ë¥¼ ì‚¬ìš©í•œë‹¤ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆë‹¤. 

&nbsp; ì¦‰, <span class="code">read</span>ë¥¼ ìˆ˜í–‰í•  ë•ŒëŠ” ì†Œì¼“ì˜ ìˆ˜ì‹  ë²„í¼ì— ë„ì°©í•œ ë°ì´í„°ë¥¼ ByteBufferë¥¼ í†µí•´ ì½ëŠ” ê²ƒì´ê³  <span class="code">write</span>ë¥¼ ìˆ˜í–‰í•  ë•ŒëŠ” ByteBufferì˜ ë‚´ìš©ì„ ì†Œì¼“ì˜ ì†¡ì‹  ë²„í¼ì— ì“°ê²Œë˜ëŠ” ê²ƒì´ë‹¤.

![socket channel diagram](/assets/img/docs/web/c10k-nio/socket-channel-diagram.png)

```java
package java.nio.channels;

public interface ReadableByteChannel extends Channel {

    /**
     * Reads a sequence of bytes from this channel into the given buffer.
     *
     * ...ìƒëµ...
     * 
     */
    public int read(ByteBuffer dst) throws IOException;
}
```

```java
package java.nio.channels;

public interface WritableByteChannel
    extends Channel
{

    /**
     * Writes a sequence of bytes to this channel from the given buffer.
     *
     * ... ìƒëµ ...
     * 
     */
    public int write(ByteBuffer src) throws IOException;

}
```

&nbsp; `SocketChannel`ì€ `WritableByteChannel`, `ReadableByteChannel`ì„ êµ¬í˜„í•˜ê³  ìˆëŠ” ì¶”ìƒ í´ë˜ìŠ¤ë¡œ `read(ByteBuffer dst)`, `write(ButeBuffer src)`ì˜ Javadoc ì£¼ì„ì„ ì½ì–´ë³´ë©´ ByteBufferë¥¼ í†µí•´ ë°ì´í„°ë¥¼ ì½ê³  ì“°ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆë‹¤.

&nbsp; ì´ë ‡ë“¯ ì±„ë„ê³¼ ë²„í¼ë¥¼ í†µí•´ ì¶”ìƒí™” ê¸°ìˆ ì„ ì œê³µí•˜ì—¬, í•˜ë‚˜ì˜ ì±„ë„ì—ì„œ ì½ê¸°ì™€ ì“°ê¸°ê°€ ê°€ëŠ¥í•˜ë„ë¡ í•˜ì—¬ ê¸°ì¡´ì˜ ìŠ¤íŠ¸ë¦¼ ë°©ì‹ì„ ì‚¬ìš©í•˜ë˜ BIOì˜ ë¬¸ì œë¥¼ ê·¹ë³µí•´ë‚´ì—ˆë‹¤. 

# Tomcatì˜ ë™ì‘ ì›ë¦¬

&nbsp; Tomcatì€ 6.0 ë²„ì „ë¶€í„° NIO ë°©ì‹ì´ ë„ì…ë˜ì–´ BIOì™€ ë™ì‹œì— ì‚¬ìš©ë˜ì—ˆìœ¼ë©°, 8.0ë¶€í„°ëŠ” NIOì—ì„œ ë¶€ê°€ê¸°ëŠ¥ì´ ë”í•´ì§„ NIO2ë¥¼ ë„ì…, 9.0ë¶€í„°ëŠ” BIOê°€ ì™„ì „íˆ ì‚­ì œë˜ì—ˆë‹¤.

&nbsp; SpringBootë¡œ REST API ì„œë²„ êµ¬ì¶• ì‹œ ì¼ë°˜ì ìœ¼ë¡œ í†°ìº£ì„ WASë¡œ ì‚¬ìš©í•˜ê²Œ ëœë‹¤. í•„ìê°€ í•´ë‹¹ í¬ìŠ¤íŒ…ì„ ì‘ì„±í•˜ê²Œ ëœ ê³„ê¸°ë„ í†°ìº£ì˜ ë™ì‘ ì›ë¦¬ì— ëŒ€í•œ ê¶ê¸ˆì¦ì— ìˆì—ˆë‹¤.

&nbsp; ì´ë²ˆ í¬ìŠ¤íŒ…ì—ì„œëŠ” í†°ìº£ì˜ ë™ì‘ ì›ë¦¬ì— ëŒ€í•œ ê°œë…ì ì¸ ì´í•´ë¥¼ ìœ„ì£¼ë¡œ ì‘ì„±í•˜ê³ , ì°¨í›„ ì½”ë“œë¥¼ ë”ìš± ìì„¸íˆ ë¶„ì„í•  ê³„íšì´ë‹¤.

![tomcat-org](/assets/img/docs/web/c10k-nio/tomcat-org.png)

![tomcat](/assets/img/docs/web/c10k-nio/tomcat.png)

&nbsp; ìœ„ [ê·¸ë¦¼](https://www.baeldung.com/spring-webflux-concurrency)ì€ ê¸°ì¡´ì˜ í†°ìº£ ë™ì‘ ì›ë¦¬ë¥¼ ë‚˜íƒ€ë‚´ëŠ” í¬ìŠ¤íŒ…ì— ë§ì´ ì‚¬ìš©ë˜ëŠ” ê·¸ë¦¼ì´ë‹¤. ì•„ë˜ ê·¸ë¦¼ì€ í•„ìê°€ ì§ì ‘ í†°ìº£ì— ì •ì˜ëœ `Acceptor`, `Poller`, `Selector` ì½”ë“œë¥¼ ì°¾ì•„ë³´ë©° ì¬êµ¬ì„±í•œ ê·¸ë¦¼ì´ë‹¤.

&nbsp; ê°„ë‹¨í•œ ë™ì‘ íë¦„ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.

1. <span class="code">Acceptor</span>ì—ì„œëŠ” ì§€ì†ì ìœ¼ë¡œ í´ë¼ì´ì–¸íŠ¸ì˜ ìš”ì²­ì´ ìˆëŠ”ì§€ í™•ì¸í•œë‹¤.
2. í´ë¼ì´ì–¸íŠ¸ì˜ ìš”ì²­ì´ ìˆ˜ë½(accept)ë˜ë©´ í•´ë‹¹ í´ë¼ì´ì–¸íŠ¸ì™€ ì—°ê²°ì„ ë‹´ë‹¹í•˜ëŠ” `SocketChannel` ê°ì²´ë¥¼ ìƒì„±í•œë‹¤.
3. `SocketChannel`ê°ì²´ì— ì¶”ìƒí™”ëœ ê¸°ìˆ ì„ ì ìš©í•œ `NioChannel`, `NioSocketWrapper`ë¡œ ê°ì‹¼ë‹¤.
4. `NioSocketWrapper`ë¥¼ <span class="code">Poller</span>ì— ë“±ë¡(register)í•œë‹¤. 
5. <span class="code">Poller</span>ëŠ” `NioSocketWrapper`ë¥¼ `PollerEvent`ë¡œ ê°ì‹¸ ë‚´ë¶€ì˜ Poller Event Queueì— ë“±ë¡í•œë‹¤. 
6. <span class="code">Poller</span>ì—ì„œëŠ” ì†Œì¼“ì˜ ì´ë²¤íŠ¸ ê°ì‹œë¥¼ ìœ„í•˜ì—¬ Poller Event Queueì˜ ì±„ë„ë“¤ì„ Selectorì— ë“±ë¡í•œë‹¤.
6. <span class="code">Selector</span>ëŠ” I/O ì¤€ë¹„ ì‘ì—… ì™„ë£Œ ì±„ë„ì„ ê°ì‹œí•œë‹¤.
7. I/O ì¤€ë¹„ ì‘ì—…ì´ ì™„ë£Œëœ ì±„ë„ì´ ë°œìƒí•˜ë©´ <span class="code">Selector</span>ë¥¼ í†µí•´ í•´ë‹¹ ì±„ë„ë“¤ì˜ SelectionKey ì•Œì•„ë‚¸ë‹¤.
8. I/O ì¤€ë¹„ ì‘ì—… ì™„ë£Œëœ ê° ì±„ë„(ìš”ì²­)ë§ˆë‹¤ Worker Threadë¥¼ í• ë‹¹í•˜ì—¬ ì²˜ë¦¬ë¥¼ ìœ„ì„í•œë‹¤.

&nbsp; í•´ë‹¹ ì„¤ëª…ì€ ì½”ë“œ íë¦„ì„ ë‹¨ìˆœí•˜ê²Œ ë‚˜ì—´í•œ ê²ƒìœ¼ë¡œ ì´í•´ë¥¼ ë•ê¸° ìœ„í•˜ì—¬ ì•„ë˜ì— ì½”ë“œë¥¼ ì¶”ê°€ì ìœ¼ë¡œ ì„œìˆ í•˜ì˜€ë‹¤. ì½”ë“œì— ëŒ€í•´ì„œëŠ” ì°¨í›„ í¬ìŠ¤íŒ…ì—ì„œ ë”ìš± ìì„¸í•˜ê²Œ ë‹¤ë¤„ë³¼ ì˜ˆì •ì´ë‹¤.

## 1. Acceptor

```java
package org.apache.tomcat.util.net;

public class Acceptor<U> implements Runnable {
    // ...
    private final AbstractEndpoint<?,U> endpoint;

    @Override
    public void run() {

        int errorDelay = 0;
        long pauseStart = 0;

        try {
            // Loop until we receive a shutdown command
            while (!stopCalled) {
                while (endpoint.isPaused() && !stopCalled) {
                    if (state != AcceptorState.PAUSED) {
                        pauseStart = System.nanoTime();
                        // Entered pause state
                        state = AcceptorState.PAUSED;
                    }
                    if ((System.nanoTime() - pauseStart) > 1_000_000) {
                        // Paused for more than 1ms
                        try {
                            if ((System.nanoTime() - pauseStart) > 10_000_000) {
                                Thread.sleep(10);
                            } else {
                                Thread.sleep(1);
                            }
                        } catch (InterruptedException e) {
                            // Ignore
                        }
                    }
                }

                if (stopCalled) {
                    break;
                }
                state = AcceptorState.RUNNING;

                try {
                    //if we have reached max connections, wait
                    endpoint.countUpOrAwaitConnection();

                    // Endpoint might have been paused while waiting for latch
                    // If that is the case, don't accept new connections
                    if (endpoint.isPaused()) {
                        continue;
                    }

                    U socket = null;
                    try {
                        // ğŸ“Œ Accept the next incoming connection from the server 
                        // socket
                        socket = endpoint.serverSocketAccept();
                    } catch (Exception ioe) {
                        // We didn't get a socket
                        endpoint.countDownConnection();
                        if (endpoint.isRunning()) {
                            // Introduce delay if necessary
                            errorDelay = handleExceptionWithDelay(errorDelay);
                            // re-throw
                            throw ioe;
                        } else {
                            break;
                        }
                    }
                    // Successful accept, reset the error delay
                    errorDelay = 0;

                    // Configure the socket
                    if (!stopCalled && !endpoint.isPaused()) {
                        // ğŸ“Œ setSocketOptions() will hand the socket off to
                        // an appropriate processor if successful
                        if (!endpoint.setSocketOptions(socket)) {
                            endpoint.closeSocket(socket);
                        }
                    } else {
                        endpoint.destroySocket(socket);
                    }
                } catch (Throwable t) {
                    ExceptionUtils.handleThrowable(t);
                    String msg = sm.getString("endpoint.accept.fail");
                    log.error(msg, t);
                }
            }
        } finally {
            stopLatch.countDown();
        }
        state = AcceptorState.ENDED;
    }

    // ...
}
```

&nbsp; ìœ„ ì½”ë“œëŠ” í†°ìº£ì˜ <span class="code">Acceptor</span> í´ë˜ìŠ¤ì™€ ë‚´ë¶€ì˜ `run()` ë©”ì„œë“œ ì½”ë“œì´ë‹¤. 

&nbsp; AcceptorëŠ” 3-way handshake ì„±ê³µ í›„ ì—°ê²°ì´ ìˆ˜ë¦½ëœ ì†Œì¼“ì„ `SocketChannel` ê°ì²´ë¡œ ë°”ì¸ë”©í•œë‹¤. ì´í›„ í•´ë‹¹ ì±„ë„ì— ëŒ€í•œ ëª‡ ê°€ì§€ ì¶”ê°€ ì„¤ì • í›„ Poller ì“°ë ˆë“œë¡œ ê°ì²´ë¥¼ ë„˜ê²¨(ë“±ë¡)ì¤€ë‹¤. AcceptorëŠ” `Runnable`ì˜ êµ¬í˜„ì²´ë¡œ í•˜ë‚˜ì˜ ì“°ë ˆë“œì´ë‹¤. 

&nbsp; `run()` ë©”ì„œë“œì—ì„œ ì¤‘ìš”í•˜ê²Œ ë³¼ ë¶€ë¶„ì€ ì•„ë˜ ë‘ ì½”ë“œì´ë‹¤.

### 1\) AbstractEndpoint.serverSocketAccept()

```java
// Accept the next incoming connection from the server
// socket
socket = endpoint.serverSocketAccept();
```

&nbsp; `endPoint`ëŠ” Acceptorì˜ ë©¤ë²„ ë³€ìˆ˜ë¡œ `NioEndpoint`, `Nio2Endpoint`ì˜ ìƒìœ„ ì¶”ìƒ í´ë˜ìŠ¤ì¸ `AbstractEndpoint` íƒ€ì…ì´ë‹¤. ì˜ˆë¥¼ ë“¤ì–´ `NioEndpoint.serverSocketAccept()` ë©”ì„œë“œë¥¼ ì‚´í´ë³´ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.

```java
public class NioEndpoint extends AbstractJsseEndpoint<NioChannel, SocketChannel> {

    /**
     * Server socket "pointer".
     */
    private volatile ServerSocketChannel serverSock = null;

    // ...

    @Override
    protected SocketChannel serverSocketAccept() throws Exception {
        SocketChannel result = serverSock.accept();

        // Bug does not affect Windows platform and Unix Domain Socket. Skip the check.
        if (!JrePlatform.IS_WINDOWS && getUnixDomainSocketPath() == null) {
            SocketAddress currentRemoteAddress = result.getRemoteAddress();
            long currentNanoTime = System.nanoTime();
            if (currentRemoteAddress.equals(previousAcceptedSocketRemoteAddress) &&
                    currentNanoTime - previousAcceptedSocketNanoTime < 1000) {
                throw new IOException(sm.getString("endpoint.err.duplicateAccept"));
            }
            previousAcceptedSocketRemoteAddress = currentRemoteAddress;
            previousAcceptedSocketNanoTime = currentNanoTime;
        }

        return result;
    }
}
```

&nbsp; ì´ ë•Œ, `ServerSocketChannel`ì€ WAS ì„œë²„ í¬íŠ¸ì™€ ì—°ê²°ì„ ë‹´ë‹¹í•˜ëŠ” ë¦¬ìŠ¤ë‹ ì†Œì¼“ì„ ì˜ë¯¸í•œë‹¤. ì¦‰, ì¼ë°˜ì ì¸ í†°ìº£ ì‚¬ìš© ì‹œ 8080í¬íŠ¸ë¡œ ë°”ì¸ë”©ëœ ì†Œì¼“ ì±„ë„ì´ë‹¤. 

&nbsp; `serverSocketAccept()` ë©”ì„œë“œ ë‚´ë¶€ì—ì„œëŠ” `serverSock.accept()`ë¥¼ í˜¸ì¶œí•˜ì—¬ í´ë¼ì´ì–¸íŠ¸ì™€ ì—°ê²° í›„, í•´ë‹¹ ì†Œì¼“ì— ëŒ€í•œ ì—°ê²°ì„ ë‚˜íƒ€ë‚´ëŠ” `SocketChannel` ê°ì²´ë¥¼ ë°˜í™˜í•œë‹¤. ê²°ê³¼ì ìœ¼ë¡œ í•´ë‹¹ ë©”ì„œë“œì—ì„œ í´ë¼ì´ì–¸íŠ¸ì™€ ì—°ê²°ì„ ë‚˜íƒ€ë‚´ëŠ” `SocketChannel` ê°ì²´ë¥¼ ë°˜í™˜í•˜ëŠ” ê²ƒì´ë‹¤.

### 2\) AbstractEndpoint.setSocketOptions(U Socket)

```java
// setSocketOptions() will hand the socket off to
// an appropriate processor if successful
if (!endpoint.setSocketOptions(socket)) {
    ..,
}
```

&nbsp; ì´ ë•Œë„ `endPoint`ëŠ” `Acceptor`ì˜ ë©¤ë²„ ë³€ìˆ˜ë¥¼ ì˜ë¯¸í•˜ë©°, ê·¸ êµ¬í˜„ì²´ ì¤‘ í•˜ë‚˜ì¸ `NioEndpoint`ë¥¼ í†µí•´ ì¶”ìƒ ë©”ì„œë“œì¸ `setSocketOptions()` êµ¬í˜„ë¶€ë¥¼ ì‚´í´ë³¸ë‹¤.

```java
/**
 * Process the specified connection.
 * @param socket The socket channel
 * @return <code>true</code> if the socket was correctly configured
 *  and processing may continue, <code>false</code> if the socket needs to be
 *  close immediately
 */
@Override
protected boolean setSocketOptions(SocketChannel socket) {
    NioSocketWrapper socketWrapper = null;
    try {
        // Allocate channel and wrapper
        NioChannel channel = null;
        if (nioChannels != null) {
            channel = nioChannels.pop();
        }
        if (channel == null) {
            SocketBufferHandler bufhandler = new SocketBufferHandler(
                    socketProperties.getAppReadBufSize(),
                    socketProperties.getAppWriteBufSize(),
                    socketProperties.getDirectBuffer());
            if (isSSLEnabled()) {
                channel = new SecureNioChannel(bufhandler, this);
            } else {
                // ğŸ“Œ NioChannelì„ ì‚¬ìš©
                channel = new NioChannel(bufhandler);
            }
        }

        // ğŸ“Œ NioChannelì„ ê°ì‹¸ê¸° ìœ„í•œ NioSocketWrapper
        NioSocketWrapper newWrapper = new NioSocketWrapper(channel, this);
        channel.reset(socket, newWrapper);
        connections.put(socket, newWrapper);
        socketWrapper = newWrapper;

        // ğŸ“Œ Non-Blocking ì²˜ë¦¬
        // Set socket properties
        // Disable blocking, polling will be used
        socket.configureBlocking(false);
        if (getUnixDomainSocketPath() == null) {
            socketProperties.setProperties(socket.socket());
        }

        socketWrapper.setReadTimeout(getConnectionTimeout());
        socketWrapper.setWriteTimeout(getConnectionTimeout());
        socketWrapper.setKeepAliveLeft(NioEndpoint.this.getMaxKeepAliveRequests());

        // ğŸ“Œ Pollerë¡œ ì „ë‹¬
        poller.register(socketWrapper);
        return true;
    } catch (Throwable t) {
        ExceptionUtils.handleThrowable(t);
        try {
            log.error(sm.getString("endpoint.socketOptionsError"), t);
        } catch (Throwable tt) {
            ExceptionUtils.handleThrowable(tt);
        }
        if (socketWrapper == null) {
            destroySocket(socket);
        }
    }
    // Tell to close the socket if needed
    return false;
}
```

&nbsp; `NioEndpoint.setSocketOptions(SocketChannel socket)` ë©”ì„œë“œì—ì„œëŠ” `SocketChannel`ì„ `NioSocketChannel`ë¡œ ê°ì‹¸ê³ , í•œ ë²ˆ ë” `NioSocketWrapper`ë¡œ ê°ì‹¸ Pollerë¡œ ì „ë‹¬í•˜ëŠ” ì—­í• ì„ ìˆ˜í–‰í•œë‹¤. ê·¸ ì™¸ì—ë„ ì†Œì¼“ì— ë…¼ë¸”ë¡œí‚¹ì„ ì ìš©í•˜ëŠ” ê³¼ì •ì´ í•´ë‹¹ ë©”ì„œë“œì—ì„œ ì´ë£¨ì–´ì§„ë‹¤. 

&nbsp; `SocketChannel.configureBlocking(false)` ë©”ì„œë“œë¥¼ ì„¤ì •í•˜ì—¬ SocketChannelì„ ë…¼ë¸”ë¡œí‚¹ ëª¨ë“œë¡œ ì„¤ì •í•œë‹¤. ë”°ë¼ì„œ, í•´ë‹¹ ì±„ë„ì— <span class="code">read</span>ë“±ì˜ ìš”ì²­ì„ ë³´ë‚´ë”ë¼ë„ ì¦‰ì‹œ ìƒíƒœê°’ì„ ë°˜í™˜í•˜ê²Œ ë˜ì–´, ìš”ì²­í•œ ì“°ë ˆë“œëŠ” ëŒ€ê¸°í•˜ì§€ ì•Šê³  ë‹¤ìŒ ë™ì‘ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆê²Œ ëœë‹¤.ë˜í•œ, ì´í›„ ì±„ë„ì„ Selectorì— ë“±ë¡í•˜ëŠ” ê³¼ì •ì—ì„œ ë¸”ë¡œí‚¹ ëª¨ë“œë¡œ ì„¤ì •ë˜ì–´ ìˆìœ¼ë©´ `IllegalBlockingModeException`ì´ ë°œìƒí•˜ê²Œ ëœë‹¤.

&nbsp; ì´ëŠ” ì°¨í›„ Selectorì—ì„œ `select()` í˜¸ì¶œ ì‹œ í•´ë‹¹ ì±„ë„ì— ëŒ€í•œ ì´ë²¤íŠ¸ ê°ì§€ ì‹œìŠ¤í…œì½œì„ í˜¸ì¶œí•´ ìƒíƒœë¥¼ ë°”ë¡œ í™•ì¸í•˜ê³ , ë‚˜ì¤‘ì— í•´ë‹¹ ì±„ë„ì— ì´ë²¤íŠ¸ ë°œìƒ ì‹œ OS ì»¤ë„ì—ì„œ ì´ë¥¼ ì•Œë ¤ Selectorì—ì„œ ê°ì§€í•  ìˆ˜ ìˆë„ë¡ í•˜ê¸° ìœ„í•¨ì´ë‹¤.

```java
package org.apache.tomcat.util.net;

public class NioEndpoint extends AbstractJsseEndpoint<NioChannel,SocketChannel> {
    private Poller poller = null;

    public class Poller implements Runnable {
        /* ... */
    }
}
```

&nbsp; NioEndpoint ë‚´ë¶€ì—ëŠ” `Poller`ë¥¼ ë©¤ë²„ ë³€ìˆ˜ë¡œ ê°€ì§€ê³  ìˆë‹¤. <span class="code">Poller</span>ëŠ” `NioEndpoint`ì˜ ë‚´ë¶€ì— ì •ì˜ëœ ì´ë„ˆ í´ë˜ìŠ¤ë¡œ `Runnable`ì˜ êµ¬í˜„ì²´ì´ë‹¤. ì¦‰ Pollerë„ ë³„ê°œì˜ ì“°ë ˆë“œì¸ ê²ƒì´ë‹¤.

&nbsp; PollerëŠ” í†°ìº£ì´ ì‹œì‘í•  ë•Œ `NioEndpoint.startInternal()` ë©”ì„œë“œê°€ ì‹¤í–‰ë˜ë©° í• ë‹¹ë˜ê²Œ ëœë‹¤. ë˜í•œ, í•´ë‹¹ ë©”ì„œë“œì—ì„œëŠ” Worker Threadì˜ Thread Poolì„ í• ë‹¹í•˜ëŠ” ì‘ì—…ë„ ì´ë£¨ì–´ì§„ë‹¤.

```java
// Acceptor.run()
poller.register(socketWrapper);
```

&nbsp; ë‹¤ì‹œ `Acceptor.run()` ë©”ì„œë“œë¡œ ëŒì•„ì™€ `poller.register(socketWrapper)` ë©”ì„œë“œë¥¼ í˜¸ì¶œí•´ ì†Œì¼“ ì±„ë„ì„ Pollerë¡œ ì „ë‹¬(ë“±ë¡)í•˜ê²Œ ëœë‹¤.

## 2. Poller & Selector

&nbsp; `Poller`ëŠ” `NioEndpoint`ì˜ ë‚´ë¶€ í´ë˜ìŠ¤ë¡œ, `Runnable`ì˜ êµ¬í˜„ì²´ì¸ ì“°ë ˆë“œì´ë‹¤.

```java
public class Poller implements Runnable {
    private Selector selector;
    private final SynchronizedQueue<PollerEvent> events = new SynchronizedQueue<>();

    /* ... */
}
```

&nbsp; `Poller`ëŠ” ë©¤ë²„ ë³€ìˆ˜ë¡œ I/O Multiplexingì„ ìœ„í•œ ì´ë²¤íŠ¸ ê°ì‹œìì¸ `Selector`ì™€ Poller Event Queueë¥¼ ë‚˜íƒ€ë‚´ëŠ” `SynchronizedQueue<PollerEvent>`ë¥¼ ê°€ì§€ê³  ìˆë‹¤. ì´ì™€ ê°™ì€ ì½”ë“œë¡œ êµ¬ì„±ë˜ì–´ ìˆê¸° ë•Œë¬¸ì— í†°ìº£ ë™ì‘ ì›ë¦¬ êµ¬ì¡° ê·¸ë¦¼ì„ ë‹¤ë¥´ê²Œ í‘œì‹œí•œ ê²ƒì´ë‹¤.

&nbsp; `Poller`ì—ì„œëŠ” í¬ê²Œ 4ê°€ì§€ì˜ ë©”ì„œë“œë¥¼ ì‚´í´ë³¼ ê²ƒì´ë‹¤. 

- <span class="code">public void register(final NioSocketWrapper socketWrapper)</span>
- <span class="code">private void addEvent(PollerEvent event)</span>
- <span class="code">public void run()</span>
- <span class="code">public boolean events()</span>

&nbsp; ì•ì„ , 2ê°€ì§€ ë©”ì„œë“œëŠ” `Acceptor`ì—ì„œ í˜¸ì¶œí•œ `poller.register(socketWrapper)`ì™€ ì—°ê´€ëœ <u>ì±„ë„ì„ Poller Event Queueì— ë“±ë¡</u>í•˜ëŠ” ì‘ì—…ê³¼ ê´€ë ¨ì´ ìˆë‹¤.

&nbsp; ì•„ë˜ì˜ 2ê°€ì§€ ë©”ì„œë“œëŠ” `Poller`ì—ì„œ ì‹¤ì œë¡œ `PollerEvent`ë¥¼ ì²˜ë¦¬í•˜ëŠ” ê³¼ì •ê³¼ ì±„ë„ì´ <span class="code">Selector</span>ì— ë“±ë¡ë˜ê³  ê°ì‹œë˜ëŠ” ê³¼ì •ê³¼ ê´€ë ¨ì´ ìˆë‹¤.

### 1\) Poller.register(final NioSocketWrapper socketWrapper)

```java
// NioEndpoint
public static final int OP_REGISTER = 0x100; //register interest op

// Poller: NioEndpointì˜ ì´ë„ˆ í´ë˜ìŠ¤
public void register(final NioSocketWrapper socketWrapper) {
    socketWrapper.interestOps(SelectionKey.OP_READ);//this is what OP_REGISTER turns into.
    PollerEvent pollerEvent = createPollerEvent(socketWrapper, OP_REGISTER);
    addEvent(pollerEvent);
}
```

&nbsp; `register(...)` ë©”ì„œë“œ ë‚´ë¶€ì—ì„œëŠ” ì „ë‹¬ë°›ì€ `NioSocketWrapper` ê°ì²´ì— ëŒ€í•˜ì—¬ ê´€ì‹¬ ì—°ì‚°(interestOps)ì„ ë“±ë¡í•œë‹¤. 

&nbsp; ì²˜ìŒ ë“¤ì–´ì˜¨ í´ë¼ì´ì–¸íŠ¸ì˜ ìš”ì²­ì€ PollerEventQueueì— ë“¤ì–´ê°ˆ ë•Œ `OP_REGISTER` ìƒíƒœë¡œ ë“¤ì–´ê°€ê²Œ ëœë‹¤. ì´í›„, í•´ë‹¹ ì±„ë„ì˜ OP_READ ì´ë²¤íŠ¸ë¥¼ ê°ì‹œí•´ì•¼í•˜ê¸° ë•Œë¬¸ì— <u>ê´€ì‹¬ì‚¬</u>ë¡œ `SelectionKey.OP_READ`ë¥¼ ì„¤ì •í•˜ëŠ” ê²ƒì´ë‹¤.

&nbsp; ì´í›„, `NioSocketWrapper` ê°ì²´ë¥¼ `PollerEvent` ê°ì²´ë¡œ ê°ì‹¸ Poller Event Queueì— ë“±ë¡í•œë‹¤. 

&nbsp; ì°¸ê³ ë¡œ, Poller Event Queueì—ëŠ” ì²˜ë§‰ ì—°ê²°ì´ ì™„ë£Œëœ ìƒíƒœì˜ ì±„ë„ê³¼ ìš”ì²­ ì²˜ë¦¬ í›„ ì†Œì¼“ì— ì‘ë‹µ ë°ì´í„° ì“°ê¸° ì—°ì‚°ì„ ìˆ˜í–‰í•´ì•¼í•˜ëŠ” ì±„ë„ì´ ë“¤ì–´ê°„ë‹¤. 

&nbsp; í•´ë‹¹ ì½”ë“œëŠ” ì´ˆê¸°ì— `Acceptor`ì—ì„œ ì—°ê²°ëœ ìš”ì²­ì„ Pollerì— ë“±ë¡í•˜ëŠ” ë¶€ë¶„ì´ë¯€ë¡œ `OP_REGISTER`ë¡œ ë“±ë¡ë˜ê²Œ ëœë‹¤.

&nbsp; ì´í›„ `addEvent(pollerEvent)`ë¥¼ í˜¸ì¶œí•˜ì—¬ í•´ë‹¹ ê°ì²´ë¥¼ ë“±ë¡í•œë‹¤.

### 2\) Poller.addEvent(PollerEvent event)

```java
private void addEvent(PollerEvent event) {
    events.offer(event);
    if (wakeupCounter.incrementAndGet() == 0) {
        selector.wakeup();
    }
}
```

&nbsp; `addEvent(PollerEvent event)` ë©”ì„œë“œì—ì„œëŠ” Poller Event Queueì— í•´ë‹¹ ìš”ì²­ì„ ì‚½ì…í•œ ë’¤ `wakeUpCounter`ë¥¼ ì¦ê°€ì‹œí‚¨ë‹¤. ì´ ë•Œ, ì²˜ë¦¬í•´ì•¼í•  ìš”ì²­ì´ ì—†ë‹¤ê°€ ìƒê²¨ë‚œ ê²½ìš°ì— <span class="code">Selector(Poller)</span>ë¥¼ ê¹¨ìš´ë‹¤.

### 3\) Poller.run()

```java
/**
 * The background thread that adds sockets to the Poller, checks the
 * poller for triggered events and hands the associated socket off to an
 * appropriate processor as events occur.
 */
@Override
public void run() {
    // Loop until destroy() is called
    while (true) {

        boolean hasEvents = false;

        try {
            if (!close) {
                // ğŸ“Œ ì²˜ë¦¬í•´ì•¼í•  ì´ë²¤íŠ¸ê°€ ìˆëŠ”ì§€ í™•ì¸ & Selectorì— ë“±ë¡
                hasEvents = events();
                if (wakeupCounter.getAndSet(-1) > 0) {
                    // If we are here, means we have other stuff to do
                    // Do a non blocking select
                    // ğŸ“Œ ì²˜ë¦¬í•´ì•¼í•  ìš”ì²­ì´ ìˆì–´ wakeUpCountê°€ 0ë³´ë‹¤ í° ê²½ìš° Non-Blocking ëª¨ë“œë¡œ ì²˜ë¦¬ ê°€ëŠ¥í•œ ì±„ë„ì´ ìˆëŠ”ì§€ í™•ì¸í•œë‹¤.
                    keyCount = selector.selectNow();
                } else {
                    // ğŸ“Œ ìš°ì„ ì€ Poller ì“°ë ˆë“œë¥¼ ëŒ€ê¸° ì‹œí‚¨ í›„, Selectorë¥¼ í†µí•´ I/O ì‘ì—…ì´ ì™„ë£Œ ì´ë²¤íŠ¸ê°€ ë°œìƒí•œ ê²½ìš° ê¹¨ì–´ë‚¨
                    keyCount = selector.select(selectorTimeout);
                }
                wakeupCounter.set(0);
            }
            if (close) {
                events();
                timeout(0, false);
                try {
                    selector.close();
                } catch (IOException ioe) {
                    log.error(sm.getString("endpoint.nio.selectorCloseFail"), ioe);
                }
                break;
            }
            // Either we timed out or we woke up, process events first
            if (keyCount == 0) {
                hasEvents = (hasEvents | events());
            }
        } catch (Throwable x) {
            ExceptionUtils.handleThrowable(x);
            log.error(sm.getString("endpoint.nio.selectorLoopError"), x);
            continue;
        }

        // ğŸ“Œ I/O ì‘ì—… ì¤€ë¹„ê°€ ì™„ë£Œëœ ì±„ë„ì˜ SelectionKeyë“¤ì„ ìˆœíšŒ
        Iterator<SelectionKey> iterator =
            keyCount > 0 ? selector.selectedKeys().iterator() : null;
        // Walk through the collection of ready keys and dispatch
        // any active event.
        while (iterator != null && iterator.hasNext()) {
            SelectionKey sk = iterator.next();
            iterator.remove();
            NioSocketWrapper socketWrapper = (NioSocketWrapper) sk.attachment();
            // Attachment may be null if another thread has called
            // cancelledKey()
            if (socketWrapper != null) {
                // ğŸ“Œ ìš”ì²­ ì²˜ë¦¬
                processKey(sk, socketWrapper);
            }
        }

        // Process timeouts
        timeout(keyCount,hasEvents);
    }

    getStopLatch().countDown();
}    
```

&nbsp; `Poller.run()` ë©”ì„œë“œ ë‚´ë¶€ì—ì„œëŠ” ë¬´í•œ ë£¨í”„ë¥¼ í†µí•´ ì„œë²„ê°€ ì¢…ë£Œë  ë•Œê¹Œì§€ ê³„ì†í•´ì„œ PollerEvent ë° I/O ì¤€ë¹„ê°€ ì™„ë£Œëœ ì±„ë„ì„ <span class="code">Selector</span>ë¥¼ í†µí•´ì„œ ì²˜ë¦¬í•œë‹¤.

&nbsp; ë°˜ë³µë¬¸ ë‚´ë¶€ì—ì„œëŠ” ë¨¼ì € `Poller.events()` ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ì—¬ PollerEventQueueì— ë“±ë¡ëœ `PollerEvent` ê°ì²´ë¥¼ Selectorì— ë“±ë¡í•œë‹¤.

---

### 3-1\) Poller.events()

```java
/**
 * Processes events in the event queue of the Poller.
 *
 * @return <code>true</code> if some events were processed,
 *   <code>false</code> if queue was empty
 */
public boolean events() {
    boolean result = false;

    PollerEvent pe = null;
    for (int i = 0, size = events.size(); i < size && (pe = events.poll()) != null; i++ ) {
        result = true;
        NioSocketWrapper socketWrapper = pe.getSocketWrapper();
        SocketChannel sc = socketWrapper.getSocket().getIOChannel();
        int interestOps = pe.getInterestOps();
        if (sc == null) {
            log.warn(sm.getString("endpoint.nio.nullSocketChannel"));
            socketWrapper.close();
        } else if (interestOps == OP_REGISTER) { // ğŸ“Œ í´ë¼ì´ì–¸íŠ¸ì™€ ì±„ë„ì´ ì²˜ìŒ ì—°ê²°ëœ ê²½ìš°
            try {
                // ğŸ“Œ OP_READ ì´ë²¤íŠ¸ë¥¼ ê°ì§€í•˜ë„ë¡ Selectorì— ë“±ë¡
                sc.register(getSelector(), SelectionKey.OP_READ, socketWrapper);
            } catch (Exception x) {
                log.error(sm.getString("endpoint.nio.registerFail"), x);
            }
        } else {
            final SelectionKey key = sc.keyFor(getSelector());
            if (key == null) {
                // The key was cancelled (e.g. due to socket closure)
                // and removed from the selector while it was being
                // processed. Count down the connections at this point
                // since it won't have been counted down when the socket
                // closed.
                socketWrapper.close();
            } else {
                final NioSocketWrapper attachment = (NioSocketWrapper) key.attachment();
                if (attachment != null) {
                    // We are registering the key to start with, reset the fairness counter.
                    try {
                        int ops = key.interestOps() | interestOps;
                        attachment.interestOps(ops);
                        key.interestOps(ops);
                    } catch (CancelledKeyException ckx) {
                        socketWrapper.close();
                    }
                } else {
                    socketWrapper.close();
                }
            }
        }
        if (running && eventCache != null) {
            pe.reset();
            eventCache.push(pe);
        }
    }

    return result;
}
```

&nbsp; `events()` ë‚´ë¶€ì—ì„œëŠ” Poller Event Queueì— ë“±ë¡ëœ ì±„ë„ë“¤ì„ ìˆœíšŒí•˜ë©° Selectorì— ë“±ë¡í•˜ëŠ” ê³¼ì •ì„ ìˆ˜í–‰í•œë‹¤.

&nbsp; ì´ë²ˆ í¬ìŠ¤íŒ…ì—ì„œëŠ” í´ë¼ì´ì–¸íŠ¸ì™€ ì±„ë„ì´ ì²˜ìŒ ì—°ê²°(<span class="code">OP_REGISTER</span>)ëœ ê²½ìš°ë¥¼ ë‚˜íƒ€ë‚´ê¸° ë•Œë¬¸ì— ì•„ë˜ ì¡°ê±´ë¬¸ì— ì˜í•´ Selectorì— ì±„ë„ì„ ë“±ë¡í•˜ê²Œ ëœë‹¤.

```java
else if (interestOps == OP_REGISTER) { // ğŸ“Œ í´ë¼ì´ì–¸íŠ¸ì™€ ì±„ë„ì´ ì²˜ìŒ ì—°ê²°ëœ ê²½ìš°
    try {
        // ğŸ“Œ OP_READ ì´ë²¤íŠ¸ë¥¼ ê°ì§€í•˜ë„ë¡ Selectorì— ë“±ë¡
        sc.register(getSelector(), SelectionKey.OP_READ, socketWrapper);
    } catch (Exception x) {
        log.error(sm.getString("endpoint.nio.registerFail"), x);
    }
} // ...
```

&nbsp; `sc.register(...)`ë¥¼ í˜¸ì¶œí•˜ì—¬ ì¸ìë¡œ ë„˜ê²¨ì¤€ `Selector` ê°ì²´ì— í•´ë‹¹ ì±„ë„ì„ ë“±ë¡í•œë‹¤. 

&nbsp; `OP_REGISTER` ìƒíƒœì˜€ë˜ ì±„ë„ì„ `SelectionKey.OP_READ`ë¡œ ë°”ê¾¸ì–´ `Selector`ì— ë“±ë¡í•œë‹¤.

&nbsp; `OP_REGISTER`ëŠ” Tomcatì˜ `Poller` í´ë˜ìŠ¤ì— ì •ì˜ëœ ìƒìˆ˜ê°’ì´ë©°, `SelectionKey.OP_READ`ëŠ” java.nioì—ì„œ ì œê³µí•˜ëŠ” ìƒìˆ˜ê°’ì´ë‹¤.

```java
// AbstractSelectableChannel
public final SelectionKey register(Selector sel, int ops, Object att) throws ClosedChannelException
{
    if ((ops & ~validOps()) != 0)
        throw new IllegalArgumentException();
    if (!isOpen())
        throw new ClosedChannelException();
    synchronized (regLock) {
        if (isBlocking())
            throw new IllegalBlockingModeException();
        synchronized (keyLock) {
            // re-check if channel has been closed
            if (!isOpen())
                throw new ClosedChannelException();
            SelectionKey k = findKey(sel);
            if (k != null) {
                k.attach(att);
                k.interestOps(ops);
            } else {
                // ğŸ“Œ New registration
                k = ((AbstractSelector)sel).register(this, ops, att);
                addKey(k);
            }
            return k;
        }
    }
}
```

&nbsp; ê²°ê³¼ì ìœ¼ë¡œ `AbstractSelector`ë¡œ íƒ€ì… ìºìŠ¤íŒ…ì„ í•˜ì—¬ ì¸ìë¡œ ì „ë‹¬ëœ Selector ê°ì²´ì— í•´ë‹¹ ì±„ë„ê³¼ ê´€ì‹¬ì‚¬(ê°ì‹œí•  ì´ë²¤íŠ¸ - <span class="code">OP_READ, OP_WRITE</span>)ë¥¼ ë“±ë¡í•˜ê²Œ ëœë‹¤.

&nbsp; ì´í›„ ìì„¸í•œ ì½”ë“œëŠ” ì°¨í›„ í¬ìŠ¤íŒ…ì—ì„œ ë‹¤ë£¨ê³ ì í•œë‹¤.

---

&nbsp; ë‹¤ì‹œ `Poller.run()` ë©”ì„œë“œë¡œ ëŒì•„ì™€ì„œ ì´í›„ I/O ì‘ì—… ì¤€ë¹„ ì™„ë£Œëœ ì±„ë„ì„ ê°ì‹œí•˜ëŠ” ê³¼ì •ì„ ì‚´í´ë³¼ ê²ƒì´ë‹¤.

```java
// Poller
/**
 * The background thread that adds sockets to the Poller, checks the
 * poller for triggered events and hands the associated socket off to an
 * appropriate processor as events occur.
 */
@Override
public void run() {
    // Loop until destroy() is called
    while (true) {

        boolean hasEvents = false;

        try {
            if (!close) {
                // ğŸ“Œ ì²˜ë¦¬í•´ì•¼í•  ì´ë²¤íŠ¸ê°€ ìˆëŠ”ì§€ í™•ì¸ & Selectorì— ë“±ë¡
                hasEvents = events();
                if (wakeupCounter.getAndSet(-1) > 0) {
                    // If we are here, means we have other stuff to do
                    // Do a non blocking select
                    // ğŸ“Œ ì²˜ë¦¬í•´ì•¼í•  ìš”ì²­ì´ ìˆì–´ wakeUpCountê°€ 0ë³´ë‹¤ í° ê²½ìš° Non-Blocking ëª¨ë“œë¡œ ì²˜ë¦¬ ê°€ëŠ¥í•œ ì±„ë„ì´ ìˆëŠ”ì§€ í™•ì¸í•œë‹¤.
                    keyCount = selector.selectNow();
                } else {
                    // ğŸ“Œ ìš°ì„ ì€ Poller ì“°ë ˆë“œë¥¼ ëŒ€ê¸° ì‹œí‚¨ í›„, Selectorë¥¼ í†µí•´ I/O ì‘ì—…ì´ ì™„ë£Œ ì´ë²¤íŠ¸ê°€ ë°œìƒí•œ ê²½ìš° ê¹¨ì–´ë‚¨
                    keyCount = selector.select(selectorTimeout);
                }
                wakeupCounter.set(0);
            }
            if (close) {
                events();
                timeout(0, false);
                try {
                    selector.close();
                } catch (IOException ioe) {
                    log.error(sm.getString("endpoint.nio.selectorCloseFail"), ioe);
                }
                break;
            }
            // Either we timed out or we woke up, process events first
            if (keyCount == 0) {
                hasEvents = (hasEvents | events());
            }
        } catch (Throwable x) {
            ExceptionUtils.handleThrowable(x);
            log.error(sm.getString("endpoint.nio.selectorLoopError"), x);
            continue;
        }

        // ğŸ“Œ I/O ì‘ì—… ì¤€ë¹„ê°€ ì™„ë£Œëœ ì±„ë„ì˜ SelectionKeyë“¤ì„ ìˆœíšŒ
        Iterator<SelectionKey> iterator =
            keyCount > 0 ? selector.selectedKeys().iterator() : null;
        // Walk through the collection of ready keys and dispatch
        // any active event.
        while (iterator != null && iterator.hasNext()) {
            SelectionKey sk = iterator.next();
            iterator.remove();
            NioSocketWrapper socketWrapper = (NioSocketWrapper) sk.attachment();
            // Attachment may be null if another thread has called
            // cancelledKey()
            if (socketWrapper != null) {
                // ğŸ“Œ ìš”ì²­ ì²˜ë¦¬
                processKey(sk, socketWrapper);
            }
        }

        // Process timeouts
        timeout(keyCount,hasEvents);
    }

    getStopLatch().countDown();
}    
```

&nbsp; `events()` ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ë©° Selectorì— ì±„ë„ì„ ë“±ë¡í•˜ê²Œ ëœë‹¤. 

&nbsp; ì´í›„, `wakeUpCounter`ì˜ ê°’ì„ í™•ì¸í•´ì„œ ì²˜ë¦¬í•´ì•¼í•  ì±„ë„ì´ ìˆë‹¤ë©´ Non-Blocking ë°©ì‹ìœ¼ë¡œ I/O ì¤€ë¹„ ì™„ë£Œëœ ì±„ë„ì˜ `SelectionKey` ê°¯ìˆ˜ë¥¼ ì¡°íšŒí•˜ëŠ” `selector.selectNow()` ë©”ì„œë“œë¥¼ í˜¸ì¶œí•œë‹¤. 

&nbsp; ê·¸ë ‡ì§€ ì•Šë‹¤ë©´ `selector.select(selectorTimeout)`ì„ í˜¸ì¶œí•˜ì—¬ `Poller` ì“°ë ˆë“œë¥¼ ëŒ€ê¸°ì‹œí‚¨ë‹¤. ì´ëŠ” ì²˜ë¦¬í•´ì•¼í•  ì±„ë„ì´ ì—†ì„ ë•ŒëŠ” `Poller` ì“°ë ˆë“œë¥¼ ëŒ€ê¸°ì‹œì¼œ ë¶ˆí•„ìš”í•œ busy waitingì„ ë°©ì§€í•˜ê¸° ìœ„í•¨ì´ë‹¤.

&nbsp; ì•ì„œ `Poller.addEvent(PollerEvent event)` ë©”ì„œë“œì—ì„œ `wakeUpCounter`ì˜ ê°’ì„ ì¦ê°€ì‹œí‚¨ ë’¤ ì²˜ë¦¬í•´ì•¼í•  ì±„ë„ì´ ìƒê¸´ ê²½ìš° `selector.wakeUp()`ì„ í˜¸ì¶œí•œ ì´ìœ ê°€ `selector.select(selectorTimeout)` ë©”ì„œë“œë¡œ ì¸í•˜ì—¬ Poller ì“°ë ˆë“œê°€ ëŒ€ê¸° ì¤‘ì¸ ê²½ìš° ê¹¨ìš°ê¸° ìœ„í•¨ì´ë¼ëŠ” ê²ƒë„ ì•Œ ìˆ˜ ìˆë‹¤.

&nbsp; ì´ ë•Œ, `selector.select()`, `selector.selectNow()` ë©”ì„œë“œë¥¼ ë”°ë¼ ë”ìš± ì €ìˆ˜ì¤€ì˜ ì½”ë“œë¡œ ì ‘ê·¼í•˜ë©´, ì•ì„œ ë³´ì•˜ë˜ `poll(...)` ë„¤ì´í‹°ë¸Œ ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ê²Œ ëœë‹¤. ì¦‰, <u>Selectorë¥¼ í†µí•´ I/O ì‘ì—…ì´ ì™„ë£Œëœ ì±„ë„ì„ ê°ì§€í•˜ì—¬ ì´í›„ ìš”ì²­ì— ëŒ€í•œ ì²˜ë¦¬ë¥¼ ì§„í–‰í•  ìˆ˜ ìˆê²Œ ë˜ëŠ” ê²ƒ</u>ì´ë‹¤.

&nbsp; í•„ìëŠ” MacOSë¥¼ ì‚¬ìš©í•˜ê¸° ë•Œë¬¸ì— JDK17ì—ì„œ [KQueueSelectorImpl](https://github.com/openjdk/jdk/blob/master/src/java.base/macosx/classes/sun/nio/ch/KQueueSelectorImpl.java)ê³¼ [PollSelectorImpl](https://github.com/openjdk/jdk/blob/master/src/java.base/unix/classes/sun/nio/ch/PollSelectorImpl.java)ì´ `SelectorImpl`ì˜ êµ¬í˜„ì²´ë¡œ ì¡´ì¬í•œë‹¤. 

&nbsp; ë³„ê°œë¡œ ìœˆë„ìš°ì—ëŠ” [WindowsSelectorImpl](https://github.com/openjdk/jdk/blob/master/src/java.base/windows/classes/sun/nio/ch/WindowsSelectorImpl.java)ê³¼ [WEPollSelectorImpl](https://github.com/openjdk/jdk/blob/master/src/java.base/windows/classes/sun/nio/ch/WEPollSelectorImpl.java) í´ë˜ìŠ¤ê°€ ì¡´ì¬í•œë‹¤.

&nbsp; BSD Unix ê³„ì—´ì˜ MacOSë¥¼ ê¸°ì¤€ìœ¼ë¡œ í•˜ì˜€ì„ ë•Œ `KQueueSelectorImpl.doSelect()` â†’ `KQueue.poll(...)` ë„¤ì´í‹°ë¸Œ ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ê²Œ ëœë‹¤.

![kqueue native poll](/assets/img/docs/web/c10k-nio/kqueue-native-poll.png)

&nbsp; KQueue.c íŒŒì¼ì—ì„œ `poll(...)` ë©”ì„œë“œë¥¼ ì°¾ì•„ë³´ë©´ <span class="code">kevent</span> ì‹œìŠ¤í…œì½œì„ í˜¸ì¶œí•˜ëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.

&nbsp; ì´í›„ì—ëŠ” `select()` ë˜ëŠ” `selectNow()`ë¡œ í˜„ì¬ I/O ì¤€ë¹„ ì‘ì—…ì´ ì™„ë£Œëœ ì±„ë„ì´ ì¡´ì¬í•  ê²½ìš°ì— `Selector.selectedKeys()` ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ì—¬ I/O ì‘ì—… ì¤€ë¹„ê°€ ì™„ë£Œëœ ì±„ë„ë“¤ì˜ `SelectionKey`ì˜ ë°˜ë³µìë¥¼ íšë“í•œë‹¤. 

&nbsp; ì´í›„, ë°˜ë³µìë¥¼ ìˆœíšŒí•˜ë©° ê° ìš”ì²­ì„ `processKey(sk, socketWrapper)` ë©”ì„œë“œë¥¼ í†µí•´ ì²˜ë¦¬í•˜ê²Œ ë˜ëŠ” ê²ƒì´ë‹¤. ì¦‰, I/O ì¤€ë¹„ ì‘ì—…ì´ ì™„ë£Œëœ ì±„ë„ì€ ìš”ì²­ë§ˆë‹¤ Worker Threadê°€ í• ë‹¹ë˜ì–´ ì´í›„ í›„ì²˜ë¦¬ë¥¼ ì§„í–‰í•˜ê²Œ ëœë‹¤. 

&nbsp; í•´ë‹¹ í¬ìŠ¤íŒ…ì—ì„œëŠ” ê°„ë‹¨í•œ ë™ì‘ ì›ë¦¬ë§Œ ì•Œì•„ë³´ê¸° ë•Œë¬¸ì— `select()`, `selectNow()`ì˜ êµ¬ì²´ì ì¸ ê³¼ì •ì´ë‚˜ `Selector`ì˜ êµ¬í˜„ì²´ë“¤ì— ëŒ€í•´ ìì„¸í•œ ì„¤ëª…ì€ ìƒëµí•˜ì˜€ë‹¤.

## ìš”ì•½

&nbsp; í†°ìº£ì˜ ë™ì‘ ì›ë¦¬(ë°©ì‹)ì„ ê°„ë‹¨í•˜ê²Œ ìš”ì•½í•˜ë©´ ë‹¤ìŒê³¼ ê°™ì„ ê²ƒì´ë‹¤.

- ì—°ê²°ì´ ìˆ˜ë¦½ëœ ìš”ì²­ì„ ë°›ëŠ” **Acceptor**, ì—°ê²°ì´ ìˆ˜ë¦½ëœ ìš”ì²­(ì±„ë„)ì„ ê´€ë¦¬í•˜ëŠ” **Poller**, ì±„ë„(ì†Œì¼“)ì˜ I/O ì‘ì—… ì™„ë£Œ ì´ë²¤íŠ¸ë¥¼ ê°ì§€í•˜ëŠ” **Selector**ê°€ ì¡´ì¬í•œë‹¤.
- ìš”ì²­ì— ëŒ€í•œ ì‹¤ì œ ì²˜ë¦¬ëŠ” Thread poolì˜ **Worker Thread**ì—ì„œ ì²˜ë¦¬í•œë‹¤.
- WASì˜ ìµœì „ì„ ì—ì„œ í´ë¼ì´ì–¸íŠ¸ì™€ì˜ ì—°ê²° ìš”ì²­ì„ ë°›ëŠ” ë¦¬ìŠ¤ë‹ ì†Œì¼“ì€ `ServerSocketChannel`ì´ë‹¤.
- ì—°ê²°ì´ ìˆ˜ë½ëœ í´ë¼ì´ì–¸íŠ¸ì˜ ìš”ì²­ì— ëŒ€í•œ ì†Œì¼“ì€ `SocketChannel`ë¡œ ë°”ì¸ë”©ëœë‹¤.
- `Acceptor`ëŠ” í´ë¼ì´ì–¸íŠ¸ì˜ ì—°ê²° ìš”ì²­ì„ ë°›ì•„ `SocketChannel`ì„ ìƒì„±í•œë‹¤.
- `Acceptor`ì—ì„œëŠ” `SocketChannel`ì„ `NioChannel`, `NiSocketWrapper`ë¡œ ê°ì‹¸ `Poller`ë¡œ ë„˜ê¸´ë‹¤.
- `Poller`ì—ì„œëŠ” `OP_REGISTER` ìƒíƒœì˜ `NioSocketWrapper`ë¥¼ ì „ë‹¬ë°›ìœ¼ë©´ ì´ë¥¼ `PolerEvent`ë¡œ ê°ì‹¸ Poller Event Queueì— ë„£ëŠ”ë‹¤.
- `Poller`ì—ì„œëŠ” `events()` ë©”ì„œë“œë¥¼ í˜¸ì¶œí•´ Poller Event Queueì˜ ìš”ì²­ì„ `Selector`ì— ì‚½ì…í•œë‹¤.
- `Poller`ëŠ” ë“±ë¡ëœ ì—¬ëŸ¬ SocketChannelë“¤ ì¤‘ I/O ì‘ì—…ì´ ì¤€ë¹„ëœ ì±„ë„ì´ ìˆëŠ”ì§€ `Selector`ë¥¼ í†µí•´ ê°ì‹œí•œë‹¤.
- `Poller` ì“°ë ˆë“œëŠ” `Selector.selectNow()`ë¥¼ í˜¸ì¶œí•˜ë©´ Non-Blocking, `Selector.select()`ë¥¼ í˜¸ì¶œí•˜ë©´ blocking ë°©ì‹ìœ¼ë¡œ ë™ì‘í•œë‹¤.
- I/O ì¤€ë¹„ ì‘ì—… ì™„ë£ŒëŠ” `epoll`, `kqueue`ì™€ ê°™ì€ ì‹œìŠ¤í…œì½œì„ í†µí•´ ê°ì§€í•  ìˆ˜ ìˆë‹¤.
- `Selector`ì˜ êµ¬í˜„ì²´ëŠ” OSë§ˆë‹¤ ë‹¤ë¥´ë‹¤. ì´ëŠ” ì´ë²¤íŠ¸ ê°ì§€ë¥¼ ìœ„í•œ ì‹œìŠ¤í…œì½œì´ ë‹¤ë¥´ê¸° ë•Œë¬¸ì´ë‹¤.
- `Poller`ì—ì„œëŠ” I/O ì¤€ë¹„ ì‘ì—…ì´ ì™„ë£Œëœ ì±„ë„ì´ ìˆì„ ê²½ìš° `Selector.selectedKeys()`ë¥¼ í†µí•´ í•´ë‹¹ ì±„ë„ë“¤ì˜ `SelectionKey`ë¥¼ ì–»ëŠ”ë‹¤.
- I/O ì¤€ë¹„ ì‘ì—…ì´ ì™„ë£Œëœ ì±„ë„ì€ ì“°ë ˆë“œ í’€ì—ì„œ Worker Threadë¥¼ í• ë‹¹ë°›ì•„ ì´í›„ ì²˜ë¦¬ë¥¼ ìˆ˜í–‰í•˜ê²Œ ëœë‹¤.

&nbsp; ìœ„ ë‚´ìš©ì´ í†°ìº£ì´ ê¸°ë³¸ì ì¸ ë™ì‘ ì›ë¦¬ë¥¼ ìš”ì•½í•œ ê²ƒì´ë‹¤. ì–´ë–»ê²Œë³´ë©´ ë§ì´ ìƒëµëœ ë‚´ìš©ì´ ë§ë‹¤ê³  ìƒê°í•  ìˆ˜ ìˆì§€ë§Œ, ì˜¤íˆë ¤ ë‚´êµ¬ êµ¬í˜„ì„ ìì„¸íˆ íŒŒê³ ë“¤ë©´ í†°ìº£ì˜ ê¸°ë³¸ ë™ì‘ ì›ë¦¬ë¼ëŠ” ì£¼ì œê°€ í¬ë¯¸í•´ì§ˆ ìˆ˜ ìˆê¸°ì— í° ë™ì‘ë§Œ ì •ë¦¬í•˜ì˜€ë‹¤.

## Tomcatì€ ì™œ Non-Blockingì¸ê°€?

&nbsp; ê²°êµ­ ìš°ë¦¬ê°€ ë³´ì•˜ë˜ `Selector.select()`ëŠ” Blocking ëª¨ë“œë¡œ ë™ì‘í•˜ì§€ë§Œ, `Selector.selectNow()`ëŠ” Non-Blocking ëª¨ë“œë¡œ ë™ì‘í•œë‹¤ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆì—ˆë‹¤.

&nbsp; í†°ìº£ì€ ì´ë ‡ë“¯ `poll`, `epoll`, `kqueue`ì™€ ê°™ì€ ì‹œìŠ¤í…œ ì½œì„ ì‚¬ìš©í•˜ì—¬ ë“±ë¡ëœ ì±„ë„ì˜ I/O ì‘ì—… ì¤€ë¹„ ì™„ë£Œ ì´ë²¤íŠ¸ë¥¼ ê°ì§€í•  ìˆ˜ ìˆê¸° ë–„ë¬¸ì— Non-Blocking ë°©ì‹ìœ¼ë¡œ ë™ì‘í•˜ë©° ì„±ëŠ¥ì„ ê°œì„ ì‹œì¼°ë‹¤.

## Tomcatì€ ì™œ êµ³ì´ Poller í´ë˜ìŠ¤ë¥¼ ë‘ì—ˆëŠ”ê°€?

&nbsp; ì•ì„œ `OP_REGISTER`ëŠ” í†°ìº£ì˜ `Poller` í´ë˜ìŠ¤ì— ì •ì˜ëœ ìƒìˆ˜ê°’ì´ê³ , `SelectionKeys.OP_READ`ë‚˜ `SelectionKeys.OP_WRITE`ëŠ” java.nioì— ì •ì˜ëœ ìƒìˆ˜ê°’ì´ë¼ ì„¤ëª…í•˜ì˜€ë‹¤.

&nbsp; ê·¸ë ‡ë‹¤ë©´ í†°ìº£ì—ì„œëŠ” ê²°êµ­ Java NIOì—ì„œ ì •ì˜í•˜ëŠ” Selectorì— ì±„ë„ì„ ë“±ë¡í•˜ê²Œ ë í…ë° ì™œ Pollerë¼ëŠ” ì“°ë ˆë“œë¥¼ ë‘ì–´ `OP_REGISTER`ì¸ ìƒíƒœë¥¼ ê±°ì¹˜ë„ë¡ í•˜ì˜€ì„ê¹Œ?

&nbsp; êµ¬ì¡°ì ìœ¼ë¡œ ì†Œì¼“ ì—°ê²° / ì±„ë„ ê´€ë¦¬ / ì´ë²¤íŠ¸ ê°ì‹œ / ì²˜ë¦¬ ì§„í–‰ ë“±ì˜ ì±…ì„(ì—­í• )ì„ ë‚˜ëˆˆ ê²ƒì™¸ì—ë„ <u>SelectorëŠ” ì“°ë ˆë“œ ì•ˆì „í•˜ì§€ ì•Šê¸°(non-thread safe)ë•Œë¬¸ì— Poller ì“°ë ˆë“œë¡œë§Œ ì ‘ê·¼ ê°€ëŠ¥</u>í•˜ë„ë¡ í•˜ëŠ” ëª©ì ë„ ì¡´ì¬í•œë‹¤.

&nbsp; `Selector.selectedKeys()` ë©”ì„œë“œì—ëŠ” ì•„ë˜ì™€ ê°™ì€ ì£¼ì„ì´ í‘œê¸°ë˜ì–´ ìˆë‹¤.

<div style="display: flex; justify-content: center;">
    <img src="/assets/img/docs/web/c10k-nio/selector-not-thread-safe.png" alt="selector-not-thread-safe" />
</div>

&nbsp; ë“±ë¡ëœ ì±„ë„ì˜ SelectionKeyë¥¼ ì €ì¥í•˜ëŠ” key-setì´ ì“°ë ˆë“œ ì•ˆì „í•˜ì§€ ì•Šë‹¤ê³  ëª…ì‹œë˜ì–´ ìˆë‹¤. ë”°ë¼ì„œ, ì—¬ëŸ¬ ì“°ë ˆë“œì—ì„œ Selectorì— ë¬´ë¶„ë³„í•œ ë™ì‹œ ì ‘ê·¼ ì‹œ ë™ì‹œì„±ìœ¼ë¡œ ì¸í•œ ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆë‹¤.

&nbsp; ë”°ë¼ì„œ, í†°ìº£ì—ì„œëŠ” `Poller` ì“°ë ˆë“œë¥¼ ë‘ì–´ í•´ë‹¹ ì“°ë ˆë“œì—ì„œë§Œ `Selector`ì— ì ‘ê·¼ ê°€ëŠ¥í•˜ë„ë¡ ì„¤ê³„í•œ ê²ƒì´ë‹¤.

# ê²°ë¡ 

&nbsp; í†°ìº£ì˜ ê¸°ë³¸ì ì¸ ë™ì‘ ì›ë¦¬ë¥¼ íƒêµ¬í•˜ë©° ì¶”ìƒì ì¸ ë‚´ìš©ìœ¼ë¡œë§Œ ì•Œê³ ìˆë˜ NIOì™€ Non-Blocking I/O ë°©ì‹ì— ëŒ€í•´ ë‹¤ì‹œê¸ˆ ì‹¤ì œ ì‚¬ë¡€ë¥¼ í†µí•´ ì•Œ ìˆ˜ ìˆëŠ” ê¸°íšŒê°€ ë˜ì—ˆë‹¤. 

&nbsp; í”íˆ Lockì„ ì œì–´í•˜ê±°ë‚˜ ë©”ì‹œì§•í ë“±ì„ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ìœ¼ë¡œ ë™ì‹œì„±ê³¼ ë¶€í•˜ ë¬¸ì œë¥¼ ê°œì„ í•˜ê¸´ í•˜ì§€ë§Œ, ê²°êµ­ WASì¸ í†°ìº£ì—ì„œ í•´ë‹¹ ìš”ì²­ë“¤ì„ ê°ë‹¹í•  ìˆ˜ ìˆì–´ì•¼ ê·¸ ì´í›„ ë¬¸ì œê¹Œì§€ ë„ë‹¬í•  ìˆ˜ ìˆë‹¤. ë”°ë¼ì„œ, í†°ìº£ì€ ì–´ë–»ê²Œ ìˆ˜ë§ì€ ìš”ì²­ì„ ê°ë‹¹í•  ìˆ˜ ìˆì„ê¹Œë¼ëŠ” ì£¼ì œë¡œ í•´ë‹¹ í¬ìŠ¤íŒ…ì„ ì¤€ë¹„í•˜ë©° ì–´ë ¤ì›€ë„ ìˆì—ˆì§€ë§Œ, ë™ì‘ ì›ë¦¬ë¥¼ í•˜ë‚˜ì”© ì´í•´í•  ë•Œë§ˆë‹¤ ì‹œì„ ì´ ë”ìš± ë„“ì–´ì§„ë‹¤ëŠ” ê²ƒì„ ëŠê¼ˆë‹¤.

&nbsp; ìë°”ì˜ ë„¤ì´í‹°ë¸Œ ë©”ì„œë“œì— ëŒ€í•´ ê°œë…ì ì¸ ì˜ë¯¸ë§Œ ì•Œê³  ìˆì—ˆëŠ”ë° ì´ë²ˆ ê¸°íšŒë¥¼ í†µí•´ ì‹œìŠ¤í…œì½œê³¼ ì—°ê²°ë˜ì–´ ì‹¤ì œ ë™ì‘ ì œì–´ì— ì‚¬ìš©ë˜ëŠ” ì‚¬ë¡€ë¥¼ í™•ì¸í•  ìˆ˜ ìˆì–´ ê¸°ë³¸ì ì¸ ìë°” ê°œë…ì—ë„ ë„ì›€ì´ ëœ ê²ƒ ê°™ë‹¤. 

&nbsp; í†°ìº£ì— ê´€í•œ ë‚´ìš©ì„ ì°¾ì•„ë³´ë©´ ê¸€ë¡œëœ ì„¤ëª…ì€ ë„ˆë¬´ ì¶”ìƒì ì´ê³ , ì‹¤ì œ ë‚´ë¶€ ì½”ë“œëŠ” ë§¤ìš° ë³µì¡í•˜ë‹¤. ë”°ë¼ì„œ, ì´ 2ê°€ì§€ë¥¼ ë³‘í–‰í•˜ì—¬ ì´í•´í•˜ê³  ë¶„ì„í•˜ì—¬ì•¼ì§€ë§Œ í•´ë‹¹ ë‚´ìš©ì„ ì´í•´í•  ìˆ˜ ìˆë‹¤. ì´ë²ˆ í¬ìŠ¤íŒ…ì„ ì‘ì„±í•˜ê¸°ê¹Œì§€ ë§ì€ ì‹œê°„ì´ ê±¸ë ¸ì§€ë§Œ í•œ ì¤„ì˜ ì½”ë“œë¥¼ ê³„ì†í•´ì„œ ë”°ë¼ê°€ë©° íƒêµ¬í•˜ë‹¤ë³´ë‹ˆ ê¸°ë³¸ì ì¸ ë™ì‘ ì›ë¦¬ ê°œë…ì„ ë” ì˜ ì´í•´í•  ìˆ˜ ìˆê²Œ ëœ ê²ƒ ê°™ë‹¤.

&nbsp; íŠ¹íˆ, <span class="code">Selector</span>ë¥¼ í†µí•œ ì´ë²¤íŠ¸ ê°ì‹œ ë°©ì‹ìœ¼ë¡œ I/O Multiplexingì„ êµ¬í˜„í•œ ê²ƒì´ ì–´ë–»ê²Œ ë³´ë©´ ê°„ë‹¨í•œ í•´ê²° ë°©ë²•ê°™ì§€ë§Œ, ì—°ê²° ìš”ì²­ì„ ìˆ˜ë½í•˜ëŠ” í´ë˜ìŠ¤ / ì±„ë„ì„ ê´€ë¦¬í•˜ëŠ” í´ë˜ìŠ¤ / ì±„ë„ì˜ ì´ë²¤íŠ¸ë¥¼ ê°ì‹œí•˜ëŠ” í´ë˜ìŠ¤ / ìš”ì²­ì„ ìˆ˜í–‰í•˜ëŠ” ì“°ë ˆë“œë¥¼ ë³„ë„ë¡œ ë‘ì–´ íš¨ìœ¨ì ì¸ Non-Blocking I/Oë¥¼ êµ¬í˜„í•œ ê²ƒì´ 

&nbsp; ë‹¤ìŒì—ëŠ” í†°ìº£ì˜ ì‹¤ì œ ì½”ë“œë¥¼ ë”ìš± ìì„¸íˆ ì‚´í´ë³´ê³ , ì–´ë– í•œ ë°©ì‹ìœ¼ë¡œ ì›¹ ì„œë²„ê°€ ìƒì„±ë˜ê³  ë™ì‘í•˜ê²Œ ë˜ëŠ”ì§€ ì„œìˆ í•  ì˜ˆì •ì´ë‹¤.

# \# Reference
- [ì‚¬ë¡€ë¥¼ í†µí•´ ì´í•´í•˜ëŠ” ë„¤íŠ¸ì›Œí¬ ë…¼ë¸”ë¡œí‚¹ I/Oì™€ Java NIO](https://mark-kim.blog/understanding-non-blocking-io-and-nio/)
- [[Tomcat] í†°ìº£ì˜ ì†Œì¼“ I/O ë°©ì‹ (Block/Non-Block, BIO/NIO)](https://jh-labs.tistory.com/334)
- [Nginx - Connection processing methods](https://nginx.org/en/docs/events.html)
- [ì˜¬ë¦¬ë¸Œì˜ - ê³ ì „ ëŒì•„ë³´ê¸°, C10K ë¬¸ì œ (C10K Problem)](https://oliveyoung.tech/2023-10-02/c10-problem/)